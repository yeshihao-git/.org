:PROPERTIES:
:ID:       3a39bdbf-179e-4dd8-aaf9-3aeb1d0c3863
:END:
#+title: 成员函数
#+filetags: cpp

* 成员函数
- 成员函数 :: 定义在类作用域中的函数
  1. *类内实现* 的成员函数 =是隐式inline= 的（因此将 类类型定义 =include= 多个文件中 不会违反 [[id:c611b7e9-f4e4-4ac4-9a84-fddb01e4275e][单一定义规则]]）
  2. *类外实现* 的成员函数（头文件、源文件） =不是隐式inline= 的 [fn:1]

*分类*
1. [[id:8f33d5f8-50b0-4825-a475-441daf2300f4][static成员函数]]
2. [[id:46717736-8049-4a3d-9507-a37e021e07b3][非static成员函数]]
3. [[id:227d0a2c-3565-4c5d-b02e-199f2d59d390][const成员函数]]
4. [[id:8866b67b-495e-4ae3-b9c6-7326dbd794f6][非const成员函数]]
5. 拷贝赋值、移动赋值之外的[[id:d39c4157-a6d7-430c-84aa-741878eaa828][运算符重载]]（注：既作为普通成员函数也能全局函数）
（注：1-5 为普通成员函数）
6. 特殊成员函数（[[id:705ffd8d-ce2d-4a2f-809d-61bb83d1c2d4][默认构造函数]]、[[id:cddd975a-e5ee-4db6-9749-dab49f962796][拷贝构造函数]]、[[id:51145ff8-f7e2-462d-96ec-01cb9e35c2cc][移动构造函数]]、[[id:be44b0c2-d234-409f-b1a6-b447e365db37][析构函数]]、[[id:6ac8d18c-f96c-489c-9da6-885f952f5491][拷贝赋值运算符]]、移动赋值运算符）

*最佳实践*
优先编写 非成员函数，类的改动不会影响 非成员函数（除非公共接口改变）-> 减少耦合[fn:2]


** 非static成员函数
:PROPERTIES:
:ID:       46717736-8049-4a3d-9507-a37e021e07b3
:END:
- 非static成员函数 :: 有 this指针，属于对象
  能调用/访问：
  1. static成员函数
  2. 非static成员函数（有 this指针）
  3. 非成员函数
  4. static成员变量
  5. 非static成员变量（有 this指针）

- this指针 :: 记录当前对象的地址（对象调用 非static成员函数 时，会将对象传入 this指针）[fn:3]
  1. 通过返回 =*this= 可以实现 *链式调用* [fn:4]


** static成员函数
:PROPERTIES:
:ID:       8f33d5f8-50b0-4825-a475-441daf2300f4
:END:
- static成员函数 :: 无 this指针，属于类
  能调用/访问：
  1. static成员函数
  2. 非成员函数
  3. static成员变量


** 非const成员函数
:PROPERTIES:
:ID:       8866b67b-495e-4ae3-b9c6-7326dbd794f6
:END:
- 非const成员函数 ::
  能调用：
  1. const成员函数
  2. static成员函数
  3. 非成员函数
  4. 非const成员函数


** const成员函数
:PROPERTIES:
:ID:       227d0a2c-3565-4c5d-b02e-199f2d59d390
:END:
- const成员函数 :: 不能通过 this指针 修改 成员变量
  能调用：
  1. const成员函数
  2. static成员函数
  3. 非成员函数



* Footnotes

[fn:1]
#+begin_src cpp :results output :namespaces std :includes <iostream>
class IDGenerator
{
private:
    static inline int s_nextID { 1 };

public:
     static int getNextID(); // 声明静态函数
};

// 类外定义静态函数，不使用 static，且不是隐式inline
// inline int IDGenerator::getNextID() { return s_nextID++; } -> 类外实现，手动设置inline
int IDGenerator::getNextID() { return s_nextID++; }

int main()
{
    for (int count{ 0 }; count < 5; ++count)
        std::cout << "The next ID is: " << IDGenerator::getNextID() << '\n';

    return 0;
}
#+end_src

[fn:2]
#+name: 成员函数 耦合 类细节（成员变量）
#+begin_src cpp :results output :namespaces std :includes <iostream> <string>
class Yogurt
{
    std::string m_flavor{ "vanilla" };

public:
    void setFlavor(std::string_view flavor)
    {
        m_flavor = flavor;
    }

    const std::string& getFlavor() const { return m_flavor; }

    // NOTE 差: 成员函数 print() 直接访问 m_flavor ->  m_flavor（类实现） 更新，需要修改 print() 实现
    void print() const
    {
        std::cout << "The yogurt has flavor " << m_flavor << '\n';
    }
};

int main()
{
    Yogurt y{};
    y.setFlavor("cherry");
    y.print();

    return 0;
}
#+end_src

#+name: 成员函数 使用 类公共接口
#+begin_src cpp :results output :namespaces std :includes <iostream> <string>
class Yogurt
{
    std::string m_flavor{ "vanilla" };

public:
    void setFlavor(std::string_view flavor)
    {
        m_flavor = flavor;
    }

    const std::string& getFlavor() const { return m_flavor; }

    // NOTE 稍好: 成员函数 不直接访问 类细节（成员变量）；类实现更新，print() 可能需要更新
    void print(std::string_view prefix) const
    {
        std::cout << prefix << ' ' << getFlavor() << '\n';
    }
};

int main()
{
    Yogurt y{};
    y.setFlavor("cherry");
    y.print("The yogurt has flavor");

    return 0;
}
#+end_src

#+name: 非成员函数
#+begin_src cpp :results output :namespaces std :includes <iostream> <string>
class Yogurt
{
    std::string m_flavor{ "vanilla" };

public:
    void setFlavor(std::string_view flavor)
    {
        m_flavor = flavor;
    }

    const std::string& getFlavor() const { return m_flavor; }
};

// NOTE 最好: 非成员函数 print() 不属于类的接口，类实现更新，但类的公共接口没更新，print() 就不需要更新
void print(const Yogurt& y)
{
        std::cout << "The yogurt has flavor " << y.getFlavor() << '\n';
}

int main()
{
    Yogurt y{};
    y.setFlavor("cherry");
    print(y);

    return 0;
}
#+end_src

[fn:3]
#+begin_src cpp :results output :namespaces std :includes <iostream>
class Simple {
private:
    int m_id{};
public:
    Simple(int id) : m_id{ id } {}
    int getID() const { return this->m_id; }        // 显式使用 this指针
    void setID(int id) { m_id = id; }               // 隐式使用 this指针
    // NOTE 编译器编译后：static void setID(Simple* const this, int id) { this->m_id = id; }
};

int main() {
    Simple simple{ 1 };
    simple.setID(2); // NOTE 编译器编译后： Simple::setID(&simple, 2);
    Simple a{1}; // this = &a 在 Simple 构造函数中
    Simple b{2}; // this = &b 在 Simple 构造函数中

    a.setID(3); // this = &a 在成员函数 setID() 中
    b.setID(4); // this = &b 在成员函数 setID() 中
}
#+end_src

[fn:4]
#+begin_src cpp :results output :namespaces std :includes <iostream>
class Calc
{
private:
    int m_value{};

public:
    Calc& add(int value) { m_value += value; return *this; }
    Calc& sub(int value) { m_value -= value; return *this; }
    Calc& mult(int value) { m_value *= value; return *this; } // 链式调用的实现：通过成员函数返回 *this 实现

    int getValue() const { return m_value; }

    void reset() { *this = {}; }          // 重置类状态的实现
};

int main()
{
    Calc calc{};
    calc.add(5).sub(3).mult(4);           // 链式调用
    std::cout << calc.getValue() << '\n'; // prints 8

    calc.reset();                         // 重置类状态
    std::cout << calc.getValue() << '\n'; // prints 0

    return 0;
}
#+end_src

#+RESULTS:
: 8
: 0
