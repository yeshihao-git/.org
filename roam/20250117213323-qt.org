:PROPERTIES:
:ID:       4012acd2-c162-4270-8c93-9922a3502f50
:END:
#+title: Qt

* 事件系统
:PROPERTIES:
:ID:       18d086af-b1a7-4731-a91d-e1607b401171
:END:
Qt程序对 各种外部/内部变化 的响应机制；事件系统可以简单理解为： =事件系统 = 产生 + 循环 + 过滤 + 分发 + 处理=

*工作流程* ：[fn:1]
1. 系统产生事件被放入系统事件队列，qt取出系统事件队列中的事件封装为qt事件放入qt事件队列，qt也会产生事件并放入qt事件队列
2. 事件循环会取出qt事件队列中的事件确定事件的目标对象，事件先经过全局事件过滤器（若app对象安装），再经过目标对象的事件过滤器（若目标对象安装），具体来说会调用事件过滤器的eventFilter()方法，若该方法返回true则拦截事件不再继续传递到目标对象，若该方法返回false则继续传递到目标对象
3. 目标对象接收到事件后会调用事件处理的入口（event()方法），event() 默认会根据事件类型调用对应的事件处理函数

** 图:事件系统之事件产生、循环、过滤、分发、处理 :ATTACH:
:PROPERTIES:
:ID:       f488468e-c836-44a2-b8a7-46d2738bc7fc
:END:
[[attachment:_20250916_140415screenshot.png]]


* 对象树
:PROPERTIES:
:ID:       c1b27c54-3d18-4f18-a4ff-d5383d2c8dc5
:END:
Qt内存管理机制，用于防止内存泄漏
1. QObject为根节点的继承体系形成的树状结构，当树中某个对象销毁时，会自动销毁它的子孙。避免内存泄漏
2. 一个对象销毁时，相关的信号槽连接会自动断开


* 信号槽
:PROPERTIES:
:ID:       350bb7f0-6acd-4a89-ab47-8433e99cef18
:END:
用于对象间通信，解耦通信双方，其次它类型安全、连接形式灵活
# （一个对象发出信号会触发另一个对象的槽函数，要使用信号槽功能 类得继承 QObject，并在类声明中增加 Q_OBJECT宏）
1. 一个信号 连接 一个槽
2. 一个信号 连接 另一个信号
3. 一个信号 连接 多个槽
4. 多个信号 连接 一个槽

*特点* ：
- 松耦合   :: 将通信双方解耦（信号发送者只需要发送信号，不需要知道接收者的存在；接收者只需关联信号，实现槽函数逻辑，无需了解发送者细节）
- 类型安全 :: （qt5）元对象系统会在编译期检查信号槽的 参数类型、参数数量
- 灵活性   ::
  1. 一个信号 连接 一个槽
  2. 一个信号 连接 另一个信号
  3. 一个信号 连接 多个槽
  4. 多个信号 连接 一个槽

*connection的2种写法* ：
- 字符串宏 :: 运行时 字符串解析检查（预处理时替换为字符串，不包含编译器可识别的类型信息）
- 函数指针 :: 编译时 参数类型/数量检查 -> 避免运行时异常，编译时检查更安全
#+begin_example cpp
// Qt4的字符串宏方式
connect(sender, SIGNAL(valueChanged(int)), receiver, SLOT(onValueChanged(int)));

// 替换后的字符串不包含编译器可识别的类型信息
SIGNAL(func(int)) 换成 "2func(int)"

// Qt5的函数指针方式
connect(sender, &Sender::valueChanged, receiver, &Receiver::onValueChanged);
// Qt5的函数指针方式：支持连接到lambda表达式
connect(sender, &Sender::valueChanged, [](int value) {
    qDebug() << "Value changed:" << value;
});
#+end_example

*connection连接方式（第5个参数）* ：
- Qt::AutoConnection（默认）   :: 自动连接
  sender 和 receiver 在同一线程 ? 直接连接 : 队列连接

- Qt::DirectConnection         :: 直接连接
  信号触发时，发送者线程直接调用槽函数

- Qt::QueuedConnection         :: 队列连接
  信号触发时，qt会将信号打包成 qt事件，放入接收者线程的事件队列，接收者线程运行事件循环从事件队列中取出事件并执行槽函数

- Qt::BlockingQueuedConnection :: 阻塞队列连接
  类似队列连接，发送者线程会被阻塞，直到接收者线程中的槽函数执行完毕

- Qt::UniqueConnection         :: 唯一连接
  与其他连接方式组合使用，用于确保 同一信号槽之间不会建立重复连接
  #+begin_example cpp
  connect(sender, &Sender::signal, receiver, &Receiver::slot, Qt::AutoConnection | Qt::UniqueConnection);
  #+end_example

信号槽机制实现依赖 *元对象系统*


* 信号槽底层原理
:PROPERTIES:
:ID:       0235f0fc-df6c-4ebb-8dc5-26b2b845ee1d
:END:
1. 元对象编译器（moc）扫描带有Q_OBJECT宏的类，提取信号、槽等元信息，生成 moc_XXX.cpp 文件
2. 程序运行到 QObject::connect，从发送者和接收者关联的moc文件中取出信号、槽对应的元索引，将 “发送者指针、信号索引、接收者指针、槽函数索引” 等信息存入内存中的QObject内部连接列表
3. 信号触发，调用发送者moc文件中的信号函数，信号函数内部调用 QMetaObject::activate() 遍历 QObject内部连接列表 找到与当前信号关联的所有 “接收者-槽”对，根据connect连接类型选择 直接调用 或 通过事件队列调用 槽函数，根据槽函数的元索引找到槽函数并调用

相关代码见：[fn:2]
#+begin_example cpp
Tom::miao() → QMetaObject::activate() → 查找连接列表 → 找到 jerry 和其槽索引 → 调用 Jerry::qt_static_metacall() → 执行 Jerry::runAway()
#+end_example


* QWidget、QDialog、QMainWindow [[https://doc.qt.io/qt-6/dialogs.html][Qt doc:dialogs]] [[https://doc.qt.io/qt-6/application-windows.html][Qt doc:mainwindow]]
*继承关系*
QWidget -+- QDialog
         +- QMainWindow

*主窗口* （QMainWindow）
作为应用程序的主界面，结构如下：
- 菜单栏（menuBar()）
- 工具栏（toolBar()）
- 状态栏（statusBar()）
- 中心部件（centralWidget()，必须设置，用于放置主要内容）
- Dock 窗口（桌面浮动窗口）

*对话框* （QDialog）
与用户交互的窗口，短期存在

*QWidget的几何结构*
见：[[id:71a4df45-b4de-47e3-9995-de2451470a90][图:QWidget的几何结构]]

** 图:QWidget的几何结构 :ATTACH:
:PROPERTIES:
:ID:       71a4df45-b4de-47e3-9995-de2451470a90
:END:
[[attachment:_20251014_153412screenshot.png]]


* 样式（QStyle）[[https://doc.qt.io/qt-6/style-reference.html#customizing-a-style][Qt doc:style]]
QStyle抽象基类封装了GUI的外观和风格，widgets使用它来执行几乎所有的绘制工作

*继承关系*
QStyle -+- QProxyStyle (用于在已有样式做局部调整)
        +- QCommonStyle(用于从零做一个全新样式)

*样式元素*
1. 基本元素    ：纯被动装饰，不参与交互，仅作视觉呈现
2. 控件元素    ：与用户交互绑定，随状态动态变化的交互性装饰
3. 复杂控件元素：包含子控件，需协调子元素布局与状态的复合交互装饰

*QStyle绘制样式元素的函数所接收的4个参数* （ =drawPrimitive()= 、 =drawControl()= 、 =drawComplexControl()= ）
# 大多数接收4个参数
1. 一个枚举值           ：要绘制的元素
2. 一个QStyleOption     ：绘制元素样式所需信息（如何以及在何处绘制该元素）
3. 一个QPainter         ：用于绘制元素
4. 一个执行QWidget的指针：被绘制元素所在的widget（可选）


* 模型/视图编程 [[https://doc.qt.io/qt-6/model-view-programming.html#introduction-to-model-view-programming][Qt doc:model-view-programming]]
:PROPERTIES:
:ID:       0b3d6765-2f2d-4a04-975a-66ad118cad4b
:END:
*组件*
- 模型 :: 负责 存储数据 以及 提供数据的读写接口
- 视图 :: 负责 从模型同步数据并显示 以及 将用户交互同步给模型
- 委托 :: 负责 视图项的自定义显示 以及 自定义编辑[fn:3]
模型索引（QModelIndex）：是三者的桥梁
协作关系见：[[id:19cef532-11de-49cb-9173-cebb2c6f2c43][图:模型/视图架构]]

*核心API*
1. 模型 通过 data()/setData() 提供数据读写接口
2. 视图 通过 setModel() 绑定模型 以及 响应信号实现显示与交互触发
3. 委托 通过 paint()/createEditor() 等实现项的自定义显示与编辑，并通过 setEditorData()/setModelData() 完成数据在模型与编辑器的同步

*模型/视图编程的优势*
1. 传统组件     ：视图和数据一体
2. 模型/视图组件：解耦视图和数据
   - 可维护性 :: 只要不修改模型的标准接口（data()、setData()、dataChanged()信号），修改模型和视图互不影响
   - 组件复用 :: 一个模型可以被多个视图复用
   - 灵活扩展 :: 支持自定义模型/视图/委托实现复杂需求，扩展性强

** 图:模型/视图架构 :ATTACH:
:PROPERTIES:
:ID:       19cef532-11de-49cb-9173-cebb2c6f2c43
:END:
[[attachment:_20251011_163129screenshot.png]]


** 图:三种视图 :ATTACH:
:PROPERTIES:
:ID:       8304c96d-89a8-4a0c-bc08-861ccc5260a6
:END:
[[attachment:_20251004_172251screenshot.png]]
列表、表格、树


* 布局管理 [[https://doc.qt.io/qt-6/layout.html][Qt doc:layout]]
用于自动排列部件中的子部件

*布局原理*
1. 按 尺寸提示 + 尺寸策略 分配默认空间
2. 按 拉伸因子比例 分配额外空间
3. 剩余空间给 “拉伸因子比例0，Expanding”组件
4. 用 “最小尺寸兜底、最大尺寸封顶” 修正边界
#+begin_comment
sizeHint（尺寸提示）：组件 “期望” 的默认大小。是组件的 “建议尺寸”（如 QPushButton 的默认大小由文字长度决定），布局会优先参考，但不是强制值。

sizePolicy（尺寸策略）：组件对 “额外空间” 的态度。核心是QSizePolicy枚举，比如：
- Fixed：固定大小，拒绝任何额外空间（只按 sizeHint 显示）
- Minimum：最小为 sizeHint，可接受额外空间（但不主动争取）
- Expanding：主动争取额外空间（优先分配多余空间）
- Maximum：最大为 sizeHint，空间不足时可缩小

拉伸因子（Stretch Factor）：布局中组件分配 “额外空间” 的比例
#+end_comment


* Qt样式表 [[https://doc.qt.io/qt-6/stylesheet.html][Qt doc:stylesheet]]
# 类似 CSS语法
用于自定义部件外观

- 选择器       :: 指定样式规则作用的 部件
- 选择器子控件 :: 指定样式规则作用的 部件的子控件（eg：QComboBox的下拉按钮）
- 选择题伪状态 :: 指定样式规则作用的 部件的状态

*样式冲突解决规则*
1. 根据选择器的特异性决定：越特异的选择器的样式优先
2. 根据级联决定，优先级  ：QApplication > 父部件 > 子部件

*继承*
不同于CSS，Qt样式表中子元素不会自动继承父元素样式，QWidget::setFont()、QWidget::setPalette()子元素会继承父元素样式
#+begin_example cpp
qApp->setStyleSheet("QGroupBox { color: red; } ");             // QGroupBox中的子元素 不会继承 父元素样式
qApp->setStyleSheet("QGroupBox, QGroupBox * { color: red; }"); // QGroupBox中的子元素 继承     父元素样式
#+end_example

*盒子模型*
见：[[id:f56c7653-55af-47ff-b0c5-a330754a97ab][图:盒子模型]]

** 图:盒子模型 :ATTACH:
:PROPERTIES:
:ID:       f56c7653-55af-47ff-b0c5-a330754a97ab
:END:
[[attachment:_20251014_135929screenshot.png]]
外边距矩形、边框矩形、内边距矩形、内容矩形


* TODO 属性系统
* TODO 元对象系统
核心：元对象系统是Qt实现信号槽、反射等特性的基础，用于在运行时获取/操作类的元信息（如类名、方法、属性等）。

关键组件：
1. `Q_OBJECT` 宏：触发元对象代码生成（需放在类声明中）。
2. 元对象编译器（moc）：预处理含 `Q_OBJECT` 的类，生成元信息代码（如信号槽关联逻辑）。
3. `QMetaObject` 类：提供运行时访问元信息的接口（如 `className()`、`invokeMethod()` 等）。
4. 继承 `QObject`：类需继承 `QObject` 以启用元对象功能。

** tmp
QObject类 为可以利用元对象系统的对象提供了基类
Q_OBJECT宏 开启元对象功能
moc 实现元对象功能

元对象系统 用于实现 信号槽机制、反射（QObject::metaObject()）


* QObject的构造和析构顺序
- 代码片段1
  #+begin_src c++
  int main(){
      QWidget window;
      QPushButton quit("Quit", &window);
      ...
  }
  #+end_src
- 代码片段2
  #+begin_src c++
  int main()
  {
      QPushButton quit("Quit");
      QWidget window;
      quit.setParent(&window);
      ...
  }
  #+end_src




* Qt Style Sheet
:PROPERTIES:
:ID:       f9dc39e4-1bcf-4677-aeea-e1f99bbc9f90
:ROAM_REFS: https://doc.qt.io/qt-6/stylesheet-syntax.html
:END:

** 语法
- style rule = selector + declaration
  #+begin_src qss
  QPushButton { color: red }
  #+end_src
  # QPushButton是selector；color: red是declaration

** 选择器类型 [[https://doc.qt.io/qt-6/stylesheet-syntax.html#selector-types][选择器类型]]

* QApplication
- 用于管理应用程序的 *全局设置* 和控制 *事件循环*
  - 全局设置 :: 应用程序的名称、图标、样式等
  - 事件循环 :: 处理用户交互、窗口更新等

* QDialog
- 模态：对话框弹出后会阻塞其他窗口（如：只有先关闭对话框才能再关闭其他窗口
- 非模态：对话框弹出后不会阻塞其他窗口


* QObject
| 函数        | 作用                                                                     |
|-------------+--------------------------------------------------------------------------|
| [[https://doc.qt.io/qt-6/qobject.html#setProperty][setProperty]] | 动态设置对象的属性(运行时对对象的属性进行操作，即使这些属性在编译时未知) |


** QMainWindow :ATTACH:
:PROPERTIES:
:ID:       9aa6e879-c71d-43fc-a774-5c6a73c8f34a
:END:
- 用于管理主窗口，QMainWindow有自己的布局
  [[attachment:_20250101_002022screenshot.png]]
1. Central Widget区域可以被任何种类的widget占用
2. 其余区域分别有对应的widget
   # QMenuBar，QToolBar，QDockWidget，QStatusBar
   | 函数             | 作用                           |
   |------------------+--------------------------------|
   | [[https://doc.qt.io/qt-6/qmainwindow.html#setCentralWidget][setCentralWidget]] | 设置Central Widget位置的widget |


* Qt Namespace
[[https://doc.qt.io/qt-6/qt.html#WindowType-enum][enum Qt::WindowType(flags Qt::WindowFlags)]]：用于设置widget的窗口系统属性


* QStyle
| 函数     | 作用                   |
|----------+------------------------|
| [[https://doc.qt.io/qt-6/qstyle.html#polish][polish]]   | 初始化widget的外观     |
| unpolish | 取消初始化widget的外观 |
# 一般和qss联动使用


* QFile
#+begin_src c++
QFile qss(":/style/stylesheet.qss");
#+end_src
在qt中，路径前的:符号表示资源文件的路径


* exec()
#+begin_src c++
int main(int argc,char * argv[])
{
    QApplication a(argc,argv);
    MainWindow w;
    w.show();
    return a.exec();
}
#+end_src
exec()作用：启动一个局部事件循环，等待用户操作完成后返回结果
# main函数返回后交给系统处理，因此可以猜到exec()和系统处理有关。
# `QApplication a(argc,argv);`将main函数中的参数传到a中，所以控制权从main转到Qt
# `return a.exec()`是进入循环等待事件的状态，等待用户和系统的消息并进行处理
# return 0;的话，就直接退出程序了
# return a.exec()就是进行循环等待事件的状态


* exec()和show()的区别
作用和区别：都是用于显示对话框，区别在于 运行机制 和 返回值
- exec()：当前线程中显示对话框，阻塞当前进程，直到用户关闭对话框。也就是说会开启一个事件循环，知道对话框关闭事件被触发
- show()：当前线程中显示对话框并返回，不会阻塞当前线程，因此程序可以执行其他代码
应用场景：
- exec()：用于显示模态对话框
- show()：用于显示 模态 和 非模态对话框


* tr()
作用：国际化使用
所有传入tr函数的文本，都可以用工具提取出来翻译成其他语言。


* C++中局部变量的销毁顺序
是按照逆序销毁
- 该例中QPushButon父类是QWidget，QWidget的父类是QObject
#+begin_src c++
int main()
{
    QWidget window;
    QPushButton quit("Quit", &window);
    ...
}
#+end_src
正确：先调用子类析构（QPushButton）后调用父类析构（QWidget）
#+begin_src c++
int main()
{
    QPushButton quit("Quit", &window);
    QWidget window;

    quit.setParent(&window);
    ...
}
#+end_src
有问题：先调用父类析构，父类析构造接着调用子类析构。然后又在销毁子类局部对象时，又调用了一次子类的析构函数


* 未处理
 只有父窗口关闭，才会回收子窗口
# 假设父窗口有一个按钮a，点击a触发槽函数，进而在堆中产生一个子窗口，我们关闭子窗口，其实子窗口是隐藏了。随着点击和关闭 重复进行，窗口会越来越多。
# 解决方法：
# 在主窗口的构造函数中 创建子窗口，析构函数中 回收子窗口，槽函数只用来控制子窗口的显示

代码片段1正确。代码片段2错误：析构顺序和构造顺序相反，先是window先析构它的children quit，然后析构自己；接下来又析构quit

* Footnotes
[fn:3]
#+begin_comment
1. 显示时，通过 paint() 等方法自定义项的外观（如用进度条展示数值）；
2. 编辑时，先通过 setEditorData() 将模型数据同步到编辑器（初始化编辑器），用户输入后，再通过 setModelData() 将编辑器数据同步到模型；
3. 模型接收新数据后，通过 dataChanged 信号通知视图，最终由视图刷新显示。
#+end_comment


[fn:1]
#+begin_example cpp
#include <QApplication>
#include <QWidget>
#include <QMouseEvent>
#include <QDebug>

// 事件过滤器对象
class EventFilter : public QObject {
    Q_OBJECT
protected:
    bool eventFilter(QObject *watched, QEvent *event) override {
        // 过滤鼠标按下事件
        if (event->type() == QEvent::MouseButtonPress) {
            qDebug() << "事件过滤器：拦截到鼠标按下事件";
            // 返回false表示事件继续传递
            return false;
        }
        return QObject::eventFilter(watched, event);
    }
};

// 自定义窗口（事件目标对象）
class MyWidget : public QWidget {
    Q_OBJECT
protected:
    // 事件分发器
    bool event(QEvent *event) override {
        if (event->type() == QEvent::MouseButtonPress) {
            qDebug() << "事件分发器：收到鼠标按下事件，准备调用处理函数";
            // 调用父类实现，会自动分发到mousePressEvent
            return QWidget::event(event);
        }
        return QWidget::event(event);
    }

    // 具体事件处理函数
    void mousePressEvent(QMouseEvent *event) override {
        qDebug() << "事件处理函数：处理鼠标按下事件，位置："
                 << event->x() << "," << event->y();
        QWidget::mousePressEvent(event);
    }
};

int main(int argc, char *argv[]) {
    QApplication app(argc, argv);

    MyWidget widget;
    EventFilter filter;

    // 为窗口安装事件过滤器
    widget.installEventFilter(&filter);

    widget.resize(300, 200);
    widget.show();

    qDebug() << "进入事件循环";
    // 启动事件循环
    return app.exec();
}

#include "main.moc"
#+end_example

[fn:2]
#+name: Tom.h
#+begin_example cpp
class Tom : public QObject
{
    Q_OBJECT
public:
    Tom(QObject *parent = nullptr) : QObject(parent) { }
    void miaow() {
        qDebug() <<  u8"喵!" ;
        emit miao();
    }

signals:
    void miao();
};
#+end_example

#+name: Jerry.h
#+begin_example cpp
class Jerry : public QObject
{
    Q_OBJECT
public:
    Jerry(QObject *parent = nullptr) : QObject(parent) {}

public slots:
    void runAway() {
        qDebug() << u8"那只猫又来了，快溜！" ;
    }
};
#+end_example

#+name: main.cpp
#+begin_example cpp
#include "Tom.h"
#include "Jerry.h"
int main(int argc, char *argv[]) {
    QCoreApplication a(argc, argv);
    Tom tom;
    Jerry jerry;

    QObject::connect(&tom, &Tom::miao, &jerry, &Jerry::runAway);
    tom.miaow();

    return a.exec();
}
#+end_example

#+name: Q_OBJECT宏
#+begin_example cpp
public: \
    QT_WARNING_PUSH \
    Q_OBJECT_NO_OVERRIDE_WARNING \
    static const QMetaObject staticMetaObject; \
    virtual const QMetaObject *metaObject() const; \
    virtual void *qt_metacast(const char *); \
    virtual int qt_metacall(QMetaObject::Call, int, void **); \
    QT_TR_FUNCTIONS \
private: \
    Q_OBJECT_NO_ATTRIBUTES_WARNING \
    Q_DECL_HIDDEN_STATIC_METACALL static void qt_static_metacall(QObject *, QMetaObject::Call, int, void **); \
    QT_WARNING_POP \
    struct QPrivateSignal {}; \
    QT_ANNOTATE_CLASS(qt_qobject, "")
/******************关键部分***********************/
static const QMetaObject staticMetaObject;
virtual const QMetaObject *metaObject() const;
virtual void *qt_metacast(const char *);
virtual int qt_metacall(QMetaObject::Call, int, void **);
static void qt_static_metacall(QObject *, QMetaObject::Call, int, void **)
#+end_example
