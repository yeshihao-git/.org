:PROPERTIES:
:ID:       ba21ede7-8cc0-48ba-9002-6e9aafa797b9
:END:
#+title: STL容器
#+filetags: cpp

* STL容器
标准库容器分为
1. 序列容器
2. 关联容器
3. 容器适配器


* 序列容器
元素顺序存储，强调 "顺序"
1. [[id:d69bd9f3-2e77-4ec3-9a7b-b655fbc7ba44][std::vector]]
   - 底层实现       :: 动态数组（运行时可以改变容量），底层连续内存空间存储元素
   - 增删改查       :: 尾增删 O(1)、头中增删 O(n)、查 O(1)
   - 扩容机制       :: 插入元素导致容量不足时触发，扩容为当前容量的1.5/2倍（GCC 2倍），将旧数据拷贝到新内存（O(n)），释放旧空间 -> *避免频繁扩容的方法* ：reserve(n) 预分配容量
   - 适用场景       :: *需要随机访问* 、尾部插入、元素数量可预测（ *扩容开销大* ）
   - 迭代器失效问题 :: 扩容后迭代器失效；中间插入/删除 点及之后的迭代器失效

2. std::list
   - 底层实现 :: 双向链表，内存空间不连续
   - 增删改查 :: 查O(n)，查到后增删 O(1)
   - 适用场景 :: *频繁增删，无需随机访问* （eg：队列）

3. std::deque
   - 底层实现 :: =管理数组 + 多个连续内存块= ：管理数组存储指向各个内存块的指针，管理数组扩容、收缩方便
   - 增删改查 :: 头尾增删 O(1)、中间增删 O(n)、查 O(1)
   - 扩容机制 :: 扩容管理数组，并用指针指向新增的内存块
   - 适用场景 :: *频繁头尾增删，需要随机访问* （结合 std::vector 和 std::list 的特点，且避免 std::vector 可能的扩容开销）


* 关联容器
元素按 key 或 key-value 存储，强调 "查找效率"
1. std::map 和 std::set
   - 底层实现 :: 红黑树（自平衡二叉搜索树）
   - 增删改查 :: 平均 O(logn)
   - key      :: 唯一、有序存储（默认升序），支持范围查询
   - 适用场景 :: 查找效率高且稳定，有序存储， *范围查找* （eg：排行榜）

2. std::unordered_map 和 [[id:9430226d-fc11-43a5-a5d7-982b0691fabe][std::unordered_set]]
   - 底层实现           :: 哈希表（数组 + 链表/红黑树，C++11后链表超过阈值转为红黑树，优化查找）
   - 增删改查           :: 平均 O(1)，最坏 O(n)（哈希冲突严重时）
   - key                :: 唯一、无序存储
   - 哈希冲突解决方法？ :: 链地址法（每个桶后接链表/红黑树）、线性探测法（下一个空位置）
   - 适用场景           :: *查找、插入效率要求极高* ，无需范围查找（eg：缓存、高频查询的字典）
   - 迭代器失效问题     ::
#+begin_src cpp :results output :namespaces std :includes <iostream>
#include <iostream>
#include <string>
#include <unordered_map>
using namespace std;

int main() {
    unordered_map<int, string> um{{1, "yeshihao"}, {3, "hahahah"}, {2, "xia"}};
    // FIXME 错误写法：由于迭代器失效，不能进行 ++it
    // for (auto it = um.begin(); it != um.end(); ++it) {
    //     um.erase(it);
    // }
    // NOTE 正确写法：用 erase的返回值更新迭代器
    for (auto it = um.begin(); it != um.end();) {
        it = um.erase(it);
    }

    cout << um.size();
}
#+end_src

#+RESULTS:
: 0


* 容器适配器
基于其他容器实现特定接口
1. std::stack：栈，后进先出
   - 底层实现 :: 默认 =deque= （也可指定 vector 或 list）
   - 核心操作 :: push、pop、top（入栈出栈访问栈顶）-> O(1)
   - 为什么默认用 deque 不用 vector ？ :: 尾部操作效率高，避免 vector 可能的扩容开销
   - 为什么默认用 deque 不用 list   ？ :: deque 内存块是连续的，无需像 list 一样存储指针，更节省内存

2. std::queue：队列，先进先出
   - 底层实现 :: 默认 =deque=
   - 核心操作 :: push、pop、front、back（入队出队访问队头队尾）-> O(1)

3. std::priority_queue：优先队列
   - 底层实现 :: 默认 =vector= ，内部维护一个 大根堆（最大元素在队头，从上往下元素值变小）
   - 核心操作 ::
     |------+---------+------------------|
     | push | O(logn) | 插入并调整堆     |
     | pop  | O(logn) | 删除堆顶并调整堆 |
     | top  | O(1)    | 访问堆顶         |
     |------+---------+------------------|
   - 如何指定大根堆/小根堆？ :: 通过比较器 greater<T> 实现小根堆
   - 底层为什么用 vector？   :: 连续内存更合适 堆索引计算（父节点i 的左孩子为 2i+1，右孩子为 2i+2）
