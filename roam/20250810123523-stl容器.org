:PROPERTIES:
:ID:       ba21ede7-8cc0-48ba-9002-6e9aafa797b9
:END:
#+title: 容器
#+filetags: cpp

* 容器
- 容器 :: 批量存储、组织对象集合，并配套[[id:63e91845-8a18-4ab3-b2b5-36e301d8ddd1][迭代器]]提供统一元素操作接口的数据结构。分为：
  1. [[id:73b28a1f-f2d1-4fea-b630-61d874ddc951][序列容器]]
  2. [[id:837e5eb4-217e-41d3-bf8d-54540980487e][关联容器]]
  3. [[id:f77ca950-6cf5-4cef-86da-279e5e2ae467][容器适配器]]


** 序列容器
:PROPERTIES:
:ID:       73b28a1f-f2d1-4fea-b630-61d874ddc951
:END:
- 序列容器 :: 元素顺序存储，强调 "顺序"
  =std::vector=
  - 底层实现       :: 动态数组（运行时可以改变容量），底层连续内存空间存储元素
  - 增删改查       :: 尾增删 O(1)、头中增删 O(n)、查 O(1)
  - 扩容机制       :: 插入元素导致容量不足时触发，扩容为当前容量的1.5/2倍（GCC 2倍），将旧数据拷贝到新内存（O(n)），释放旧空间 -> *避免频繁扩容的方法* ：reserve(n) 预分配容量
  - 适用场景       :: *需要随机访问* 、尾部插入、元素数量可预测（ *扩容开销大* ）
  - 迭代器失效问题 :: 扩容后迭代器失效；中间插入/删除 点及之后的迭代器失效

  =std::list=
  - 底层实现 :: 双向链表，内存空间不连续
  - 增删改查 :: 查O(n)，查到后增删 O(1)
  - 适用场景 :: *频繁增删，无需随机访问* （eg：队列）

  =std::deque=
  - 底层实现 :: 管理数组 + 多个连续内存块 ：管理数组存储指向各个内存块的指针，管理数组扩容、收缩方便
  - 增删改查 :: 头尾增删 O(1)、中间增删 O(n)、查 O(1)
  - 扩容机制 :: 扩容管理数组，并用指针指向新增的内存块
  - 适用场景 :: *频繁头尾增删，需要随机访问* （结合 std::vector 和 std::list 的特点，且避免 std::vector 可能的扩容开销）


** 关联容器
:PROPERTIES:
:ID:       837e5eb4-217e-41d3-bf8d-54540980487e
:END:
- 关联容器 :: 元素按 key 或 key-value 存储，强调 "查找效率"
  =std::map= 和 =std::set=
  - 底层实现 :: 红黑树（自平衡二叉搜索树）
  - 增删改查 :: 平均 O(logn)
  - key      :: 唯一、有序存储（默认升序），支持范围查询
  - 适用场景 :: 查找效率高且稳定，有序存储， *范围查找* （eg：排行榜）

  =std::unordered_map= 和 =std::unordered_set=
  - 底层实现           :: 哈希表（数组 + 链表/红黑树，C++11后链表超过阈值转为红黑树，优化查找）
  - 增删改查           :: 平均 O(1)，最坏 O(n)（哈希冲突严重时）
  - key                :: 唯一、无序存储
  - 哈希冲突解决方法？ :: 链地址法（每个桶后接链表/红黑树）、线性探测法（下一个空位置）
  - 适用场景           :: *查找、插入效率要求极高* ，无需范围查找（eg：缓存、高频查询的字典）
  - 迭代器失效问题     ::
#+begin_src cpp :results output :namespaces std :includes <iostream> <string> <unordered_map>
int main() {
    unordered_map<int, string> um{{1, "yeshihao"}, {3, "hahahah"}, {2, "xia"}};
    // FIXME 错误写法：由于迭代器失效，不能进行 ++it
    // for (auto it = um.begin(); it != um.end(); ++it) {
    //     um.erase(it);
    // }
    // NOTE 正确写法：用 erase的返回值更新迭代器
    for (auto it = um.begin(); it != um.end();) {
        it = um.erase(it);
    }

    cout << um.size();
}
#+end_src

#+RESULTS:
: 0


** 容器适配器
:PROPERTIES:
:ID:       f77ca950-6cf5-4cef-86da-279e5e2ae467
:END:
- 容器适配器 :: 基于其他容器实现特定接口
  =std::stack= ：栈，后进先出
  - 底层实现 :: 默认 =deque= （也可指定 vector 或 list）
  - 核心操作 :: push、pop、top（入栈出栈访问栈顶）-> O(1)
  - 为什么默认用 deque 不用 vector ？ :: 尾部操作效率高，避免 vector 可能的扩容开销
  - 为什么默认用 deque 不用 list   ？ :: deque 内存块是连续的，无需像 list 一样存储指针，更节省内存

  =std::queue= ：队列，先进先出
  - 底层实现 :: 默认 =deque=
  - 核心操作 :: push、pop、front、back（入队出队访问队头队尾）-> O(1)

  =std::priority_queue= ：优先队列
  - 底层实现 :: 默认 =vector= ，内部维护一个 大根堆（最大元素在队头，从上往下元素值变小）
  - 核心操作 ::
    |------+---------+------------------|
    | push | O(logn) | 插入并调整堆     |
    | pop  | O(logn) | 删除堆顶并调整堆 |
    | top  | O(1)    | 访问堆顶         |
    |------+---------+------------------|
  - 如何指定大根堆/小根堆？ :: 通过比较器 greater<T> 实现小根堆
  - 底层为什么用 vector？   :: 连续内存更合适 堆索引计算（父节点i 的左孩子为 2i+1，右孩子为 2i+2）


** 迭代器
:PROPERTIES:
:ID:       63e91845-8a18-4ab3-b2b5-36e301d8ddd1
:END:
- 迭代器 :: 提供 *统一接口* 访问、遍历和操作容器中元素， *解耦* 容器和算法
  1. 迭代器类通常作为嵌套类 *定义* 在容器类中（eg：std::string::iterator 是 std::string 的嵌套类），不支持迭代器（C风格数组）的可以使用 =std::begin()= 、 =std::end()= [fn:1]
  2. *迭代器比较* 使用 =operator!== 而不是 operator< ：前者所有迭代器都支持（不使用迭代器的普通循环使用 后者）
  3. *迭代器失效* ：容器大小改变（正在迭代的元素 *改变地址或销毁* ）[fn:2]


*** 基于范围的for循环
:PROPERTIES:
:ID:       16a242cf-3eae-4c15-a5ff-6ad713d50029
:END:
- 基于范围的for循环 :: （cpp11）简化的循环语法，底层是基于[[id:63e91845-8a18-4ab3-b2b5-36e301d8ddd1][迭代器]]实现的，注意 *迭代器失效* 问题


* Footnotes

[fn:1]
#+begin_src cpp :results output :namespaces std :includes <iostream>
int arr[] = {1,2,3};
auto beg = std::begin(arr);
auto end = std::end(arr);

for (; beg != end; ++beg) {
  cout << *beg << '\n';
}
#+end_src

[fn:2]
#+name: 基于范围的for循环
#+begin_src cpp :results output :namespaces std :includes <iostream> <vector>
std::vector v { 0, 1, 2, 3 };

for (auto num : v)  { // 基于范围的for：背后使用迭代器
    if (num % 2 == 0)
        v.push_back(num + 1); // NOTE 迭代器失效
    cout << num << '\n';
}

#+end_src

#+RESULTS:
: 0
: 5
: 30164373
: -898947855
