:PROPERTIES:
:ID:       599c0029-f742-474f-8c86-1c6521201900
:END:
#+title: 函数
#+filetags: cpp

* 函数
- 函数 :: 有命名，可复用的代码块，调用函数时（ =operator()= ）跳转到函数地址[fn:1]，由 *函数签名* 唯一标识。分为：
  1. 全局函数
  2. 类的[[id:3a39bdbf-179e-4dd8-aaf9-3aeb1d0c3863][成员函数]]

- 函数签名 :: 函数签名 = 函数名 + 函数参数（类型、数量、顺序）+ 函数级const限定符
  + 函数名 :: 是标识符，在需要函数指针的地方可以 隐式转换为 [[id:ee21abb8-cd89-4207-bbbe-49c4ed887fed][函数指针]] [fn:2]


** 函数参数
*** 传递方式
四种传递方式的示例 [fn:3]


**** 值传递
:PROPERTIES:
:ID:       3a04e3db-6905-4108-9167-57b30217eedc
:END:
- 值传递 :: 复制对象，访问的是副本
  1. *使用场景* ：基本数据类型、枚举类型
  2. *开销* ：复制成本低的对象，访问对象快，编译器可能进行优化


**** 引用传递
:PROPERTIES:
:ID:       5a3b3112-2058-42bf-8e3b-03f33dd9fda0
:END:
- 引用传递 :: 引用对象，访问的是对象本身
  1. *使用场景* ：类类型
  2. *开销* ：复制成本高的对象，访问对象慢（值传递 程序直接访问对象，引用传递 先访问引用所在位置，再解引用，访问被引对象所在位置）
  3. *底层* ：本质上是地址传递，地址传递 = 传递地址的值 = 值传递，因此底层是 *值传递*


**** 地址传递
:PROPERTIES:
:ID:       21305f89-3a4e-49c7-a102-6bf510c5d144
:END:
- 地址传递 :: 复制对象地址，可以修改地址里的变量，不能修改地址
  1. *底层* ：地址传递 = 传递地址的值 = 值传递，因此底层是 *值传递*


**** 对地址的引用传递
:PROPERTIES:
:ID:       4f78c4ee-bc67-4a74-985a-6282bc0d6be3
:END:
- 对地址的引用传递 :: 引用对象地址，可以修改地址


** 默认参数
:PROPERTIES:
:ID:       85ecef21-d8cb-4005-a398-fba8bafce2a4
:END:
- 默认参数 :: 函数形参的默认值
  1. 默认参数 *右边* 必须是 默认参数 [fn:4]
  2. 默认参数 *不能同时出现* 在函数 [[id:ca54a01f-2f2f-4b35-b5e1-2bc51a5b456c][前向声明]] 和 [[id:0a007e7b-1391-4161-b0e2-63e2fc93502e][定义]] 中 [fn:5]
     *[最佳实践]* 默认参数在 [[id:fbf786c2-5b6e-47a1-81b9-c1c644b567bb][头文件]] 中前置声明 [fn:6]
  3. 默认参数 可以用于 [[id:6c92dc3d-9ce0-4d40-9597-5ecc93ea3366][函数重载]]，但可能模糊匹配 [fn:7]


** 函数重载
:PROPERTIES:
:ID:       a545a441-471f-45d4-8a7b-30767486357a
:END:
- 函数重载 :: 同一作用域内多个同名函数，通过 *函数重载解析规则* 匹配函数
  *why* ：相同功能的函数因为类型不同而需要创建新的函数名，函数名增多导致管理困难 [fn:8]


*** 函数重载解析规则
作用域中已[[id:1752c1cb-3fd8-4272-96c9-fa73e14a7d3c][声明]]的函数，参与重载解析（含 =delete 删除的函数）
调用重载函数，编译器根据 *函数参数（类型、数量、顺序）* 匹配函数， *不包括返回类型*
1. 精确匹配（或 [[id:7285203f-83ad-4954-ad9c-9175eba4c5c3][平凡转换]] 得到的精确匹配 [fn:9]）
2. [[id:fa26fb7c-14c0-41e5-bd3b-8ecd9c7c4c01][算术提升]] [fn:10]
3. [[id:fa26fb7c-14c0-41e5-bd3b-8ecd9c7c4c01][算术转换]] [fn:11]
4. [[id:a5cc8359-125f-45a2-8901-4858134c09c3][用户定义转换]] [fn:12]
5. =...= 省略号匹配
6. 匹配错误（eg： *ambiguous match（模糊匹配）* [fn:13]）


** 函数的早期绑定、晚期绑定
:PROPERTIES:
:ID:       fe21da2b-7236-41e5-a1b8-f763532f8907
:END:
- 早期绑定 :: 编译时，函数定义和函数调用绑定 [fn:14]
  效率高：跳转到函数地址
  不灵活

- 晚期绑定 :: 运行时，函数定义和函数调用绑定（通过 [[id:ee21abb8-cd89-4207-bbbe-49c4ed887fed][函数指针]] 实现）[fn:15]
  效率低：读取指针中存储的地址 -> 跳转到函数地址
  灵活（eg：运行时根据用户输入选择函数）


** =delete
:PROPERTIES:
:ID:       82d44637-d24d-485d-847c-b59ad9d88048
:END:
- =delete :: （cpp11） *禁用函数调用* ，而 *非删除声明* （ =delete 修饰的函数可以参与[[id:a545a441-471f-45d4-8a7b-30767486357a][函数重载]]）。可以修饰：
  1. 全局[[id:599c0029-f742-474f-8c86-1c6521201900][函数]]
  2. 类的[[id:3a39bdbf-179e-4dd8-aaf9-3aeb1d0c3863][成员函数]]（见 *分类* ，=delete 修饰的特殊成员函数 编译器不会合成）

* Footnotes

[fn:1]
#+begin_src cpp :results output :namespaces std :includes <iostream>
int foo() { return 5; }    // foo 代码在内存地址 0x002717f0 开始

int main() {
    foo();                 // 通过 operator() 跳到地址 0x002717f0
    cout << foo() << '\n'; // 输出 函数调用的返回值
    cout << foo << '\n';   // NOTE 函数名 隐式转换为指针，函数指针非空，bool 为 true（1）
}
#+end_src

#+RESULTS:
: 5
: 1

[fn:2]
#+begin_src cpp
// 函参中的函数名 隐式转换为函数指针
void selectionSort(int* array, int size, bool comparisonFcn(int, int))
// 函数指针形式
void selectionSort(int* array, int size, bool (*comparisonFcn)(int, int))
#+end_src

[fn:3]
#+begin_src cpp :results output :namespaces std :includes <iostream> <string>
void printByValue(std::string val) {            // 值传递
    std::cout << val << '\n';
}

void printByReference(const std::string& ref) { // 引用传递
    std::cout << ref << '\n';
}

void printByAddress(const std::string* ptr)  {  // 地址传递（复制了一份地址），可以修改地址里变量的值，不能修改地址（因为只是地址的拷贝）
    std::cout << *ptr << '\n';
}

void nullify(int*& refptr)  {                   // 地址引用传递（对地址的引用），可以修改地址（因为是对地址的引用）
    refptr = nullptr;
}

int main() {
    std::string str{ "Hello, world!" };

    printByValue(str);     // 值传递, makes a copy of str
    printByReference(str); // 引用传递, does not make a copy of str
    printByAddress(&str);  // 地址传递, does not make a copy of str

    int x{ 5 };
    int* ptr{ &x };
    nullify(ptr);
}
#+end_src

#+RESULTS:
: Hello, world!
: Hello, world!
: Hello, world!

[fn:4]
#+begin_src cpp :results output :namespaces std :includes <iostream>
void print(int x=10, int y); // FIXME
void print(std::string_view sv="Hello", double d=10.0);

int main() {
    print(20.0);             // FIXME
}
#+end_src

[fn:5]
#+begin_src cpp :results output :namespaces std :includes <iostream>
void print(int x, int y=4);  // 前向声明

void print(int x, int y=4) { // FIXME: 重定义默认参数
    std::cout << "x: " << x << '\n';
    std::cout << "y: " << y << '\n';
}
#+end_src

[fn:6]
#+name: foo.h
#+begin_src cpp :results output :namespaces std :includes <iostream>
#ifndef FOO_H
#define FOO_H
void print(int x, int y=4);
#endif
#+end_src

#+name: main.cpp
#+begin_src cpp :results output :namespaces std :includes <iostream>
#include "foo.h"

void print(int x, int y) {
    std::cout << "x: " << x << '\n';
    std::cout << "y: " << y << '\n';
}

int main() {
    print(5);
}
#+end_src

[fn:7]
#+name: 默认参数 用于 函数重载
#+begin_src cpp
void print(int x);                  // print(int)
void print(int x, int y = 10);      // print(int, int)
void print(int x, double y = 20.5); // print(int, double)
#+end_src

#+name: 默认参数 可能导致 模糊匹配
#+begin_src cpp
void print(int x);                  // print(int)
void print(int x, int y = 10);      // print(int, int)
void print(int x, double y = 20.5); // print(int, double)

int main() {
    print(1, 2);   // 解析为 print(int, int)
    print(1, 2.5); // 解析为 print(int, double)
    print(1);      // FIXME ambiguous function call
}
#+end_src

[fn:8]
#+begin_comment
add(int x, int y) 只能用于 int 相加，对于 double 类型，我们需要创建新的函数名，例如：add_double(double x, double y)
随着函数名增多导致管理困难 -> 解决方式：函数重载
#+end_comment

[fn:9]
#+begin_src cpp :results output :namespaces std :includes <iostream> <string>
void foo(const int) {
  cout << "const int " << endl;
}

void foo(const double&) { // double& is a reference to a double
  cout << "const double&" << endl;
}

int main()
{
    int x { 1 };
    foo(x); // 平凡转换：int -> const int

    double d { 2.3 };
    foo(d); // 平凡转换：double -> const double& (non-ref to ref conversion)
}
#+end_src

#+RESULTS:
: const int
: const double&

[fn:10]
#+begin_src cpp :results output :namespaces std :includes <iostream> <string>
void foo(int) {
  cout << "int" << endl;
}

void foo(double) {
  cout << "double" << endl;
}

int main()
{
    foo('a');  // 提升：char  -> int
    foo(true); // 提升：bool  -> int
    foo(4.5f); // 提升：float -> double
}
#+end_src

#+RESULTS:
: int
: int
: double

[fn:11]
#+begin_src cpp :results output :namespaces std :includes <iostream> <string>
void foo(double) { }

void foo(std::string) { }

int main()
{
    foo('a'); // 转换：char -> double

    return 0;
}
#+end_src

[fn:12]
#+begin_src cpp :results output :namespaces std :includes <iostream>
class X {
public:
    operator int() { return 0; } // 用户定义的转换：X -> int
};

void foo(int) {
  cout << "int" << endl;
}

void foo(double) {
  cout << "double" << endl;
}

int main()
{
    X x;
    foo(x); // 用户定义的转换：x is converted to type int using the user-defined conversion from X to int
}
#+end_src

#+RESULTS:
: int

[fn:13]
#+begin_src cpp :results output :namespaces std :includes <iostream>
void foo(int) {
  cout << "int" << endl;
}

void foo(double) {
  cout << "double" << endl;
}

int main() {
    foo(5L); // FIXME 出现模棱两可错误：5L is type long
}
#+end_src

[fn:14]
#+name: 早期绑定
#+begin_src cpp :results output :namespaces std :includes <iostream>
int add(int x, int y) { return x + y; }

int subtract(int x, int y) { return x - y; }

int multiply(int x, int y) { return x * y; }

int main() {
    int x{};
    std::cout << "Enter a number: ";
    std::cin >> x;

    int y{};
    std::cout << "Enter another number: ";
    std::cin >> y;

    int op{};
    std::cout << "Enter an operation (0=add, 1=subtract, 2=multiply): ";
    std::cin >> op;

    int result {};
    switch (op)
    {
        // 早期绑定：编译时将函数调用和函数定义绑定
        case 0: result = add(x, y); break;
        case 1: result = subtract(x, y); break;
        case 2: result = multiply(x, y); break;
        default:
            std::cout << "Invalid operator\n";
            return 1;
    }
    std::cout << "The answer is: " << result << '\n';
}
#+end_src

[fn:15]
#+name: 晚期绑定
#+begin_src cpp :results output :namespaces std :includes <iostream>
int add(int x, int y) { return x + y; }

int subtract(int x, int y) { return x - y; }

int multiply(int x, int y) { return x * y; }

int main() {
    int x{};
    std::cout << "Enter a number: ";
    std::cin >> x;

    int y{};
    std::cout << "Enter another number: ";
    std::cin >> y;

    int op{};
    std::cout << "Enter an operation (0=add, 1=subtract, 2=multiply): ";
    std::cin >> op;

    using FcnPtr = int (*)(int, int); // 函数指针的别名
    FcnPtr fcn { nullptr };           // 创建函数指针 fcn

    // 根据用户选择，将 fcn 指向具体函数
    switch (op)
    {
        case 0: fcn = add; break;
        case 1: fcn = subtract; break;
        case 2: fcn = multiply; break;
        default:
            std::cout << "Invalid operator\n";
            return 1;
    }

    // 晚期绑定：在编译时，编译器无法确定 fcn 指向哪个函数
    std::cout << "The answer is: " << fcn(x, y) << '\n';

    return 0;
}
#+end_src
