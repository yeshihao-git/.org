:PROPERTIES:
:ID:       60cbe68b-543d-46b5-a5b2-89452e8ec901
:ROAM_ALIASES: cpp实现单例模式、工厂模式
:END:
#+title: C++实现单例模式、工厂模式
#+filetags: cpp

* 单例模式
- 单例模式 :: 创建一个唯一的实例，提供全局访问点，保证所有访问单例的客户端，获取到单例的信息都是共享的
  1. 代码：[fn:1] [fn:2]


* 工厂模式
- 工厂模式 :: 将对象的 *创建和使用分离* ，降低系统耦合度（添加新类型只需修改工厂类）、易于维护（创建逻辑改变不会影响客户端代码）
  1. *简单工厂模式* ：一个工厂根据传入参数创建产品，需要修改工厂类来添加新产品，不符合开闭原则，适合 产品少且无需扩展 的情况 [fn:3]
  2. *工厂方法模式* ：定义一个用于创建对象的接口，让派生类决定实例化哪个产品，一个工厂生产一种产品，通过新增工厂的方式添加新产品，符合开闭原则，适合 产品需要扩展 的情况 [fn:4]
  3. *抽象工厂模式* ：适合 需要创建产品族 的情况 [fn:5]

* Footnotes

[fn:1]
#+name: 单例模式
#+begin_src cpp :results output :namespaces std :includes <iostream> <thread>
class Singleton{
public:
    static Singleton& getInstance() {
        static Singleton instance;
        return instance;
    }

    ~Singleton() = default;

    void print() const {
        cout << this << endl;
    }
private:
    Singleton() = default;
    Singleton(const Singleton&) = delete;
    Singleton& operator=(const Singleton&) = delete;
};

int main() {
    thread t1([](){
        Singleton::getInstance().print();
    });

    thread t2([](){
        Singleton::getInstance().print();
    });

    t1.join();
    t2.join();
}
#+end_src

#+RESULTS: 单例模式
: 0x555d7eba7191
: 0x555d7eba7191

[fn:2]
#+begin_src cpp :results output :namespaces std :includes <iostream>
/* 线程安全的配置管理类 */
#include <iostream>
#include <string>
#include <mutex>
#include <thread>
#include <unordered_map>
using namespace std;

class ConfigManager {
public:
    static ConfigManager& getInstance() {
        static ConfigManager instance;
        return instance;
    }

    string getConfig(const string& key) const{
        lock_guard<mutex> lock(mtx); // getConfig是const的，不允许修改；但对mutex加锁会修改mutex内部状态，因此成员变量为 mutable mutex mtx;
        // return configs[key]; -> getConfig是const的，不允许修改；configs[key]会在key不存在时插入新元素，这会修改map
        auto it = configs.find(key);
        if (it != configs.end()) {
            return it->second;
        }
        return "";
    }

    void setConfig(const string& key, const string& value) {
        lock_guard<mutex> lock(mtx);
        configs[key] = value;
    }

    void displayAll() {
        lock_guard<mutex> lock(mtx);
        for (auto& config:configs) {
            cout << config.first << " " << config.second << endl;
        }
    }
private:
    ConfigManager() {
        configs["host"] = "localhost";
        configs["port"] = "8080";
        configs["timeout"] = "30";
    }
    ConfigManager(const ConfigManager&) = delete;
    ConfigManager& operator=(const ConfigManager&) = delete;
    ConfigManager(ConfigManager&&) = delete;
    ConfigManager& operator=(ConfigManager&&) = delete;

    unordered_map<string, string> configs;
    mutable mutex mtx;
    static ConfigManager instance;
};

ConfigManager ConfigManager::instance;

int main() {
    thread t1([](){
        auto& config = ConfigManager::getInstance();
        for (int i = 0; i < 5; ++i) {
            config.setConfig("key" + to_string(i), "value" + to_string(i));
        }
    });

    thread t2([](){
        auto& config = ConfigManager::getInstance();
        for (int i = 0; i < 5; ++i) {
            config.setConfig("key" + to_string(i+10), "value" + to_string(i));
        }
    });

    thread t3([](){
        auto& config = ConfigManager::getInstance();
        this_thread::sleep_for(chrono::milliseconds(10));
        config.displayAll();
    });

    t1.join();
    t2.join();
    t3.join();

    cout << "\nHost: " << ConfigManager::getInstance().getConfig("host") << endl;
}
#+end_src

#+RESULTS:
#+begin_example
key4 value4
key14 value4
key12 value2
key3 value3
key10 value0
key2 value2
key13 value3
key1 value1
key11 value1
key0 value0
timeout 30
port 8080
host localhost

Host: localhost
#+end_example

[fn:3]
#+name: 简单工厂模式
#+begin_src cpp :results output :namespaces std :includes <iostream>
#include <iostream>
#include <memory>

// 支付接口
class Payment {
public:
    virtual ~Payment() = default;
    virtual void pay(double amount) = 0;
};

// 支付宝支付
class Alipay : public Payment {
public:
    void pay(double amount) override {
        std::cout << "使用支付宝支付: " << amount << "元" << std::endl;
    }
};

// 微信支付
class WechatPay : public Payment {
public:
    void pay(double amount) override {
        std::cout << "使用微信支付: " << amount << "元" << std::endl;
    }
};

// 银联支付
class UnionPay : public Payment {
public:
    void pay(double amount) override {
        std::cout << "使用银联支付: " << amount << "元" << std::endl;
    }
};

// 简单支付工厂
class PaymentFactory {
public:
    enum PaymentType { ALIPAY, WECHAT, UNION };

    static std::unique_ptr<Payment> createPayment(PaymentType type) {
        switch (type) {
            case ALIPAY: return std::make_unique<Alipay>();
            case WECHAT: return std::make_unique<WechatPay>();
            case UNION: return std::make_unique<UnionPay>();
            default: throw std::invalid_argument("不支持的支付类型");
        }
    }
};

int main() {
    // 客户端使用
    auto alipay = PaymentFactory::createPayment(PaymentFactory::ALIPAY);
    alipay->pay(100.50);

    auto wechat = PaymentFactory::createPayment(PaymentFactory::WECHAT);
    wechat->pay(200.00);

    return 0;
}
#+end_src

#+RESULTS:
: 使用支付宝支付: 100.5元
: 使用微信支付: 200元

[fn:4]
#+name: 工厂方法模式
#+begin_src cpp :results output :namespaces std :includes <iostream>
#include <iostream>
#include <memory>
#include <string>

// 日志记录器接口
class Logger {
public:
    virtual ~Logger() = default;
    virtual void log(const std::string& message) = 0;
};

// 文件日志
class FileLogger : public Logger {
public:
    void log(const std::string& message) override {
        std::cout << "写入文件日志: " << message << std::endl;
    }
};

// 控制台日志
class ConsoleLogger : public Logger {
public:
    void log(const std::string& message) override {
        std::cout << "控制台输出: " << message << std::endl;
    }
};

// 数据库日志
class DatabaseLogger : public Logger {
public:
    void log(const std::string& message) override {
        std::cout << "存入数据库: " << message << std::endl;
    }
};

////// 日志工厂接口
class LoggerFactory {
public:
    virtual ~LoggerFactory() = default;
    virtual std::unique_ptr<Logger> createLogger() = 0;
};

// 文件日志工厂
class FileLoggerFactory : public LoggerFactory {
public:
    std::unique_ptr<Logger> createLogger() override {
        return std::make_unique<FileLogger>();
    }
};

// 控制台日志工厂
class ConsoleLoggerFactory : public LoggerFactory {
public:
    std::unique_ptr<Logger> createLogger() override {
        return std::make_unique<ConsoleLogger>();
    }
};

// 数据库日志工厂
class DatabaseLoggerFactory : public LoggerFactory {
public:
    std::unique_ptr<Logger> createLogger() override {
        return std::make_unique<DatabaseLogger>();
    }
};

int main() {
    // 根据配置决定使用哪种日志
    std::unique_ptr<LoggerFactory> factory;

    // 这里可以根据配置文件或环境变量选择工厂
    factory = std::make_unique<FileLoggerFactory>();

    auto logger = factory->createLogger();
    logger->log("系统启动完成");

    return 0;
}
#+end_src

#+RESULTS: 工厂方法模式
: 写入文件日志: 系统启动完成

[fn:5]
#+name: 抽象工厂模式
#+begin_src cpp :results output :namespaces std :includes <iostream>
#include <iostream>
#include <memory>
#include <string>

// 抽象按钮
class Button {
public:
    virtual ~Button() = default;
    virtual void render() = 0;
    virtual void onClick() = 0;
};

// 抽象文本框
class TextBox {
public:
    virtual ~TextBox() = default;
    virtual void render() = 0;
    virtual void setText(const std::string& text) = 0;
};

// Windows风格按钮
class WindowsButton : public Button {
public:
    void render() override {
        std::cout << "渲染一个Windows风格的按钮" << std::endl;
    }

    void onClick() override {
        std::cout << "Windows按钮被点击" << std::endl;
    }
};

// Windows风格文本框
class WindowsTextBox : public TextBox {
public:
    void render() override {
        std::cout << "渲染一个Windows风格的文本框" << std::endl;
    }

    void setText(const std::string& text) override {
        std::cout << "Windows文本框设置文本: " << text << std::endl;
    }
};

// Mac风格按钮
class MacButton : public Button {
public:
    void render() override {
        std::cout << "渲染一个Mac风格的按钮" << std::endl;
    }

    void onClick() override {
        std::cout << "Mac按钮被点击" << std::endl;
    }
};

// Mac风格文本框
class MacTextBox : public TextBox {
public:
    void render() override {
        std::cout << "渲染一个Mac风格的文本框" << std::endl;
    }

    void setText(const std::string& text) override {
        std::cout << "Mac文本框设置文本: " << text << std::endl;
    }
};

// 抽象UI工厂
class UIFactory {
public:
    virtual ~UIFactory() = default;
    virtual std::unique_ptr<Button> createButton() = 0;
    virtual std::unique_ptr<TextBox> createTextBox() = 0;
};

// Windows UI工厂
class WindowsUIFactory : public UIFactory {
public:
    std::unique_ptr<Button> createButton() override {
        return std::make_unique<WindowsButton>();
    }

    std::unique_ptr<TextBox> createTextBox() override {
        return std::make_unique<WindowsTextBox>();
    }
};

// Mac UI工厂
class MacUIFactory : public UIFactory {
public:
    std::unique_ptr<Button> createButton() override {
        return std::make_unique<MacButton>();
    }

    std::unique_ptr<TextBox> createTextBox() override {
        return std::make_unique<MacTextBox>();
    }
};

// 客户端代码
class Application {
private:
    std::unique_ptr<UIFactory> factory_;

public:
    Application(std::unique_ptr<UIFactory> factory) : factory_(std::move(factory)) {}

    void createUI() {
        auto button = factory_->createButton();
        auto textbox = factory_->createTextBox();

        button->render();
        button->onClick();

        textbox->render();
        textbox->setText("Hello World");
    }
};

int main() {
    // 根据当前操作系统选择工厂
    #ifdef _WIN32
        auto factory = std::make_unique<WindowsUIFactory>();
    #else
        auto factory = std::make_unique<MacUIFactory>();
    #endif

    Application app(std::move(factory));
    app.createUI();

    return 0;
}
#+end_src

#+RESULTS: 抽象工厂模式
: 渲染一个Mac风格的按钮
: Mac按钮被点击
: 渲染一个Mac风格的文本框
: Mac文本框设置文本: Hello World
