:PROPERTIES:
:ID:       3c8eb7cf-68ed-4359-8e3f-f7c620b49fc0
:END:
#+title: mysql事务
#+filetags: mysql

* mysql事务 [[https://xiaolincoding.com/mysql/transaction/mvcc.html#%E4%BA%8B%E5%8A%A1%E6%9C%89%E5%93%AA%E4%BA%9B%E7%89%B9%E6%80%A7][小林coding]]
*mysql事务* ：数据库操作的 *最小执行单元* （包含一个或多个SQL语句），要么全部执行成功，要么全部执行失败
# mysql原生的 MyISAM引擎 不支持事务

** 事务的特性
| 特性     | 说明                                                       | 如何实现             |
|----------+------------------------------------------------------------+----------------------|
| 原子性 A | 一个事务的所有操作，要么全部完成，要么全部不完成           | undo log             |
| 一致性 C | 事务前后，数据库状态一致                                   | 持久性+原子性+隔离性 |
| 隔离性 I | 多个事务读写数据，互不干扰                                 | MVCC 或 锁机制       |
| 持久性 D | 事务结束后，对数据的修改就是永久的。就算系统故障也不会丢失 | redo log             |
- undo log :: 回滚日志
- redo log :: 重做日志
- MVCC     :: 多版本并发控制


* 事务隔离性（隔离性 I）
事务隔离性：数据库允许多个事务并发访问数据

*事务并发访问引发的问题* ：
（按严重性排序：高 -> 低）
- 脏读       :: 读到其他事务未提交的数据
- 不可重复读 :: 前后读取数据不一致（一个事务多次读取同一数据，前后读到的数据不一致）
- 幻读       :: 前后读取数据数量不一致（一个事务多次查询符合某个条件的记录数量，前后读到的数量不一致）

因此 SQL标准提出了 4种隔离级别，隔离级别越高，性能效率越低

*事务隔离级别* ：见[[id:fe05559c-4b0d-4951-af21-9099943f08ce][图:四种隔离级别示例]]
（按隔离级别排序：低 -> 高，级别越高性能越低）
| 隔离级别 | 说明                             | 实现方式                                           | 解决的问题             |
|----------+----------------------------------+----------------------------------------------------+------------------------|
| 读未提交 | 可以读到其他事务未提交数据       | 直接读最新数据                                     |                        |
| 读提交   | 可以读到其他事务提交数据         | 每次读取数据时生成一个新的 Read View               | 脏读                   |
| 可重复读 | 事务执行中看到的数据和启动时一致 | 启动事务时，生成一个 Read View，整个事务期间都在用 | 脏读、不可重复读       |
| 串行化   | 通过锁机制强制事务串行执行       | 读写锁                                             | 脏读、不可重复读、幻读 |
MySQL InnoDB引擎 默认的隔离级别：可重复读，解决幻读的方式
- 快照读（普通select语句）           ：读历史快照。MVCC
- 当前读（select ... for update语句）：读最新数据。next-key lock（记录锁+间隙锁）
MVCC保证读的时候看不到幻影；next-key lock保证写的时候造不出幻影

#+name: 题外话-两种开启事务的方式
#+begin_comment
1. begin/start transaction                   ：执行这条命令后，再执行第一条 select语句，事务开启
2. start transaction with consistent snapshot：执行这条命令后，事务开启
#+end_comment

** 图:四种隔离级别示例 :ATTACH:
:PROPERTIES:
:ID:       fe05559c-4b0d-4951-af21-9099943f08ce
:END:
[[attachment:_20250828_194857screenshot.png]]
- 读未提交 隔离级别下：事务 B 修改余额后，虽然没有提交事务，但是此时的余额已经可以被事务 A 看见了，于是事务 A 中余额 V1 查询的值是 200 万，余额 V2、V3 自然也是 200 万了；
- 读提交 隔离级别下  ：事务 B 修改余额后，因为没有提交事务，所以事务 A 中余额 V1 的值还是 100 万，等事务 B 提交完后，最新的余额数据才能被事务 A 看见，因此额 V2、V3 都是 200 万；
- 可重复读 隔离级别下：事务 A 只能看见启动事务时的数据，所以余额 V1、余额 V2 的值都是 100 万，当事务 A 提交事务后，就能看见最新的余额数据了，所以余额 V3 的值是 200 万；
- 串行化 隔离级别下  ：事务 B 在执行将余额 100 万修改为 200 万时，由于此前事务 A 执行了读操作，这样就发生了读写冲突，于是就会被锁住，直到事务 A 提交后，事务 B 才可以继续执行，所以从 A 的角度看，余额 V1、V2 的值是 100 万，余额 V3 的值是 200 万。


* MVCC
** MVCC简易版本
多版本并发控制，用于解决 *可重复读* 隔离级别下 *快照读* 中的 *幻读* 问题
1. *本质* ：每个事务读同一个数据，读到的是自己对应的历史版本，所以多个事务既能同时读，也能同时写，读写互不阻塞，实现数据库高并发
2. 历史版本来自 undo log，一条记录与undo log串成一条版本链
3. 当前事务能看到版本链的哪一个版本取决于 ReadView，它会记录哪些事务已提交，哪些事务还没提交 =->= 自己改的、比自己早提交的能看；晚提交的不能看
*读提交*   ：每次查询生成一个新的 ReadView -> 因此前后两次select结果可能不一样，因此不可重复读；具体示例见：[[https://xiaolincoding.com/mysql/transaction/mvcc.html#%E8%AF%BB%E6%8F%90%E4%BA%A4%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84][小林coding]]
*可重复读* ：启动事务时生成一个 Read View，整个事务期间都在用这个 ReadView；具体示例见：[[https://xiaolincoding.com/mysql/transaction/mvcc.html#%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84][小林coding]]

** MVCC详细版本
*关键组件* ：
1. 记录行结构中通过 undo log 形成的版本链
2. Read View

*MVCC（多版本并发控制）原理* ：[[id:3e9e5c9f-a1db-4a6c-b921-f2a33b2abbcc][图:Read View结构、COMPACT行结构中的隐藏列、MVCC原理]]

*** 图:Read View结构、COMPACT行结构中的隐藏列、MVCC原理 :ATTACH:
:PROPERTIES:
:ID:       3e9e5c9f-a1db-4a6c-b921-f2a33b2abbcc
:END:
*COMPACT行结构中的隐藏列* ：
[[attachment:_20250828_201747screenshot.png]]
1. trx_id      ：改动该行记录的事务ID
2. roll_pointer：一个指向旧版本记录的指针 -> 每次对记录改动时，会将旧版本记录写入 undo log，并将 roll_pointer 执行它（通过它我们能找到旧版本记录）

*Read View结构* ：
[[attachment:_20250828_200921screenshot.png]]
事务快照结构；事务创建时，内存中临时生成的一个数据结构，事务结束后就销毁；有以下4个字段
- creator_trx_id :: 创建该 Read View 的事务的事务ID
- m_ids          :: 创建 Read View 时，已启动但未提交的事务ID列表
- min_trx_id     :: 已启动但未提交的事务ID列表 中 最小的事务ID；创建 Read View 时，m_ids中的最小值
- max_trx_id     :: 系统即将分配给下一个新事务的事务ID（创建 Read View 时），也就是 =全局事务中最大的事务ID + 1=

*MVCC原理* ：
[[attachment:_20250828_200928screenshot.png]]
一个事务访问记录时
1. 自己更新的记录， *可见*
2. =（记录的 trx_id）<  （Read View的 min_trx_id）= ， *可见*   （说明该版本的记录是由创建 Read View 前 已提交的事务生成）
3. =（记录的 trx_id）>​= （Read View的 max_trx_id）= ， *不可见* （说明该版本的记录是由创建 Read View 后 启动的事务生成）
4. =（Read View的 min_trx_id）<=（记录的 trx_id）<（Read View的 max_trx_id）= -> *对应 m_ids 部分*
   - 记录的 trx_id *在*   Read View的 m_ids列表 中， *不可见* （说明生成该版本记录的事务还在运行且未提交）
   - 记录的 trx_id *不在* Read View的 m_ids列表 中， *可见*   （说明生成该版本记录的事务还在运行且提交）
不可见的情况下，顺着版本链查找可见的 trx_id

