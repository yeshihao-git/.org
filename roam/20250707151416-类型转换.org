:PROPERTIES:
:ID:       1b0646eb-ed64-4b37-a394-4974750aaf7a
:END:
#+title: 类型转换
#+filetags: cpp

* 类型转换
- 类型转换 :: 数据从 *一种类型转换为另一种类型* ，转换过程中会生成 *目标类型的临时值* ，分为：
  1. 隐式类型转换
  2. 强制类型转换（显式类型转换）

** 隐式类型转换
:PROPERTIES:
:ID:       fa26fb7c-14c0-41e5-bd3b-8ecd9c7c4c01
:END:
- 隐式类型转换 :: 编译器自动触发的类型转换
  *why* ：[fn:1]

#+name: 14种隐式类型转换
|---------------------+----------------------------------+------------------------------------------------------------------+----------------+----------------|
| 类别                | 子项                             | 说明                                                             | 属于[[id:7285203f-83ad-4954-ad9c-9175eba4c5c3][平凡转换]]？ | 包含[[id:1c7e9842-2dee-43ce-a9cb-94672516adb3][窄化转换]]？ |
|---------------------+----------------------------------+------------------------------------------------------------------+----------------+----------------|
| 值转换              | 左值转右值                       | 左值 -> 右值                                                     | 是             | 否             |
|                     | 数组退化                         | 数组 -> 指针                                                     | 是             | 否             |
|                     | 函数退化                         | 函数 -> 指针                                                     | 是             | 否             |
|                     | 临时对象构造                     | 值   -> 临时对象                                                 | 否             | 否             |
|---------------------+----------------------------------+------------------------------------------------------------------+----------------+----------------|
| 限定符转换          | 限定符转换                       | 增/删 限定符const / volatile                                     | 是             | 否             |
|---------------------+----------------------------------+------------------------------------------------------------------+----------------+----------------|
| 算术提升 *why* [fn:2] | 整型提升                         | 小整型类型 -> int / unsigned int                                 | 否（安全）     | 否             |
|                     | 浮点提升                         | float -> double                                                  | 否（安全）     | 否             |
|---------------------+----------------------------------+------------------------------------------------------------------+----------------+----------------|
| 算术转换            | 整型转换（非整型提升的整型转换） | 其他类型 -> 整型                                                 | 否             | 是             |
|                     | 浮点转换（非浮点提升的浮点转换） | 其他类型 -> 浮点                                                 | 否             | 是             |
|                     | 整数-浮点转换                    | 整型 -> 浮点                                                     | 否             | 部分           |
|                     | 布尔转换                         | 整型、无作用域枚举、指针 -> bool                                 | 否             | 否             |
|---------------------+----------------------------------+------------------------------------------------------------------+----------------+----------------|
| 指针转换            | 指针转换                         | std::nullptr -> 指针 / 指针 -> void指针 / 派生类指针 -> 基类指针 | 部分           | 否             |
|                     | 成员指针转换                     | std::nullptr -> 成员指针 / 基类成员指针 -> 派生类成员指针        | 否             | 否             |
|                     | 函数指针转换                     | 无noexcept函数指针 -> 函数指针                                   | 否             | 否             |
|---------------------+----------------------------------+------------------------------------------------------------------+----------------+----------------|

*** 平凡转换
:PROPERTIES:
:ID:       7285203f-83ad-4954-ad9c-9175eba4c5c3
:END:
- 平凡转换 :: 无开销，无风险的转换（语法层面的类型解释，不涉及内存布局/语义）。以下转换为平凡转换：
  1. 左值    -> 右值（左值出现在右边时）
  2. 非const -> 顶层const
  3. 非引用  -> 引用
  4. 数组退化指针
  5. 函数退化指针

*** 窄化转换
:PROPERTIES:
:ID:       1c7e9842-2dee-43ce-a9cb-94672516adb3
:END:
- 窄化转换 :: 精度缺失的转换

** 强制类型转换
:PROPERTIES:
:ID:       a5cc8359-125f-45a2-8901-4858134c09c3
:END:
- 强制类型转换 :: 程序员明确指示编译器进行的类型转换
  *why* [fn:3]

#+name: 强制类型转换种类
|-----------------------+-------------------------------------------------------------+-----------------|
| 种类                  | 描述                                                        | 安全？          |
|-----------------------+-------------------------------------------------------------+-----------------|
| std::static_cast      | 编译期类型转换                                              | 是              |
| std::dynamic_cast     | 运行期类型转换（指针或引用在多态体系中的转换）              | 是              |
| std::const_cast       | 添加/删除 const                                             | 增加const时安全 |
| std::reinterpret_cast | 逐bit的将一个类型转为另一种类型                             | 否              |
| C-style casts         | 底层是 static_cast、const_cast、reinterpret_cast 的一些组合 | 否              |
|-----------------------+-------------------------------------------------------------+-----------------|

*** std::static_cast
:PROPERTIES:
:ID:       010e73aa-c20b-49c0-be60-800c41b10462
:END:
- std::static_cast :: （静态类型转换）编译时类型转换，提供编译时检查（相比于 C风格转换 更安全）。用于： *基本类型转换* 、 *向上转型* [fn:4]
  *坑* ：用于 向下转型[fn:4] 时因为没有运行时检查，因此转型总是成功，但是访问转型后的对象可能出现未定义行为

*** std::dynamic_cast
:PROPERTIES:
:ID:       5da43f35-39b6-4d7e-9d04-3221a6a092e7
:END:
- std::dynamic_cast :: （动态类型转换）运行时类型转换，提供运行时检查，失败返回空指针，在 *多态体系* 中使用，用于 *指针/引用的向下转型* [fn:5]

**** 向下转型失效 的情况
   1) protected 或 private 继承
   2) 不是有虚函数的继承体系

**** 选择：向下转型 和 虚函数
*优先 虚函数* ，以下情况使用 向下转型：
1. 需要访问特定于派生类的内容（eg：仅在派生类中定义的函数）
2. 无法修改基类以添加虚函数  （eg：基类是标准库一部分）

*** std::const_cast
:PROPERTIES:
:ID:       1ca01478-b225-49b4-a3ce-025b3cb5ce80
:END:
- std::const_cast :: （const转换）用于去除对象的const属性。对象本身不是const/volatile，后来被加上 const/volatile，才能用 const_cast 去除对象的const/volatile属性，const_cast 只能用于指针/引用
#+begin_src cpp :results output :namespaces std :includes <iostream>
void modify(const char* str) {      // 2. 函数参数是 const，导致 str 变成 const
  char* p = const_cast<char*>(str); // 3. const_cast 去除const
  p[0] = 'H';
}

int main() {
  char str[] = "hello";             // 1. 对象本身不是 const
  modify(str);
  cout << str <<'\n';
}
#+end_src

#+RESULTS:
: Hello

*** std::reinterpret_cast
:PROPERTIES:
:ID:       fd1b6149-4506-4bf9-abd0-279fa6792490
:END:
- std::reinterpret_cast :: （重解释转换）逐bit的将一种类型转换为另一种类型，无检查，风险极高，用于 *指针之间/引用间转换* 或 *指针/引用与整数间的转换*
#+begin_src cpp :results output :namespaces std :includes <iostream> <cstdint>
int a = 42;
uintptr_t addr = reinterpret_cast<uintptr_t>(&a); // 指针转为整数
int* p = reinterpret_cast<int*>(addr);            // 整数转为指针
cout << *p << "\n";
#+end_src

#+RESULTS:
: 42


* Footnotes

[fn:1]
#+name: 如果没有隐式类型转换...
#+begin_src cpp :results output :namespaces std :includes <iostream> <cstring>
int main() {
  int n { 3 };
  float f {};
  memcpy(&f, &n, sizeof(float)); // 无隐式转换：逐字节将 n 拷贝到 f，由于编译器对数据类型的解释，会打印出奇怪的值
  cout << f << endl;

  f = n;                         // 有隐式转换：打印出期望的值
  cout << f << endl;
}
#+end_src

#+RESULTS: 如果没有隐式类型转换...
: 4.2039e-45
: 3

[fn:2]
CPU处理数据更高效（eg：32位CPU 处理 int（32位）相比 char（8位）更快）

[fn:3]
#+begin_src cpp :results output :namespaces std :includes <iostream>
int x = 10, y = 4;
double d = x / y;               // 结果为2.0，因为 先进行 x / y 得到 int 2，然后转为 double 2.0
cout << d << '\n';

/* 强制类型转换 */
d = static_cast<double>(x) / y; // 结果为2.5，因为 x 转为 double 10.0，根据 算数转换，y 转为 double 4.0
cout << d << '\n';
#+end_src

#+RESULTS:
: 2
: 2.5

[fn:4]
#+name: 基本类型转换
#+begin_src cpp :results output :namespaces std :includes <iostream>
double d = 3.14;
int i = static_cast<int>(d);
cout << i << '\n';
#+end_src

#+RESULTS: 基本类型转换
: 3

[fn:5]
#+name: 向下转型
#+begin_src cpp :results output :namespaces std :includes <iostream>
/* 有虚函数的继承体系 */
struct Base {
    virtual ~Base() {} // 有虚函数
};
struct Derived : Base {};

Base* b = new Derived;
Derived* d = dynamic_cast<Derived*>(b); // ok
if (b) {
  cout << "转换成功" << '\n';
} else {
  cout << "转换失败" << '\n';
}

/* 没有虚函数的继承体系 */
struct NonPolyBase {}; // 没有虚函数
struct NonPolyDerived : NonPolyBase {};
NonPolyBase* npb = new NonPolyDerived;
// NonPolyDerived* npd = dynamic_cast<NonPolyDerived*>(npb); // FIXME 不是有虚函数的继承体系，无法使用 std::dynamic_cast
#+end_src

#+RESULTS: 向下转型
: 转换成功

#+name: 转换失败返回空指针
#+begin_src cpp :results output :namespaces std :includes <iostream>
class Base { virtual void f() {} };
class Derived : public Base {};

int main() {
  Base* b = new Base();                   // 指向基类对象
  Derived* d = dynamic_cast<Derived*>(b); // 转换失败，d为nullptr
  if (d) {
    cout << "转换成功" << '\n';
  } else {
    cout << "转换失败" << '\n';
  }
  delete b;
}
#+end_src
