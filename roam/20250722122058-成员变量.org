:PROPERTIES:
:ID:       372c18aa-a68a-47b2-a5b8-9685e7677a69
:END:
#+title: 成员变量
#+filetags: cpp

* 成员变量
- 成员变量 :: 类作用域中的变量
  成员变量除了[[id:59279fc7-7896-47f4-908d-25e78cfc2d54][基本数据类型]]，还可以是：
  1. [[id:d091d455-5933-4047-92fb-4c2d2d2f7ff9][枚举]]（推荐 [[id:c93ba44b-9830-47e0-bef3-43c403be7d29][无作用域枚举]] [fn:1]）
  2. [[id:15357ed3-3530-4c07-b743-9af983e05e96][类型别名]] [fn:2]
  3. 嵌套[[id:d63526f2-db09-4c79-8a1a-57d6a7d82ec9][类]]：
     1) 嵌套类 *不能直接访问外部类成员* ，但能通过传入外部类对象 *访问外部类的私有成员* [fn:3]
     2) 嵌套类 *能在 外部类内前向声明* ， *外部类内或外定义* [fn:4]
     3) 嵌套类 *不能在 外部类定义前 前向声明* [fn:5]

*分类*
1. [[id:fcea15d9-fa33-4320-9853-0275ec8319f2][static成员变量]]
2. [[id:53173b3f-8828-4e0c-8a09-d5a6035ad3c8][非static成员变量]]
3. [[id:8775da35-dc16-4293-9448-8a6dbdfaa382][const成员变量]]
4. [[id:b9555eb4-85ef-4674-a0ad-7a31baf28373][引用成员变量]]


** static成员变量
:PROPERTIES:
:ID:       fcea15d9-fa33-4320-9853-0275ec8319f2
:END:
- static成员变量 :: 属于类，所有对象共享唯一副本
  1. 静态存储期，类外定义，默认初始化为 0
#+begin_example cpp
<类名>::<static成员变量>  // 可在 类没有实例化 时，通过类名访问
#+end_example

*初始化*
1. 类外初始化（推荐） [fn:6]
2. 类内初始化 [fn:7]
   a. static const int（包括 char、bool）
   b. （cpp17）static inline
   c. （cpp17）static constexpr


** 非static成员变量
:PROPERTIES:
:ID:       53173b3f-8828-4e0c-8a09-d5a6035ad3c8
:END:
- 非static成员变量 :: 属于对象，每个对象拥有独立的副本


** const成员变量
:PROPERTIES:
:ID:       8775da35-dc16-4293-9448-8a6dbdfaa382
:END:
- const成员变量 :: 必须在 [[id:50402d44-720e-42ed-b590-2b18d219acc1][构造函数]]成员初始化列表 中初始化，不可修改


** 引用成员变量
:PROPERTIES:
:ID:       b9555eb4-85ef-4674-a0ad-7a31baf28373
:END:
- 引用成员变量 :: 必须在 [[id:50402d44-720e-42ed-b590-2b18d219acc1][构造函数]]成员初始化列表 中初始化，不可修改绑定对象


* Footnotes

[fn:1]
#+begin_src cpp :results output :namespaces std :includes <iostream>
class Fruit {
public:
    enum Type {                                // 无作用域枚举类：枚举成员直接使用类作用域，类内直接访问
      apple,
      banana,
      cherry
    };

private:
  Type m_type {};
  int m_percentageEaten { 0 };
public:
  Fruit(Type type) : m_type { type } {}
  Type getType() { return m_type;  }
  int getPercentageEaten() { return m_percentageEaten;  }
  bool isCherry() { return m_type == cherry; } // 类内直接访问枚举成员
};

int main() {
  Fruit apple { Fruit::apple };                // 类外访问枚举成员，使用 Fruit 前缀

  if (apple.getType() == Fruit::apple)
    std::cout << "I am an apple";
  else
    std::cout << "I am not an apple";
}
#+end_src

#+RESULTS:
: I am an apple

[fn:2]
#+begin_src cpp :results output :namespaces std :includes <iostream> <string> <string_view>
class Employee {
public:
    using IDType = int;                   // 类 嵌套 类型别名（using、typedef）
private:
    std::string m_name{};
    IDType m_id{};
    double m_wage{};
public:
    Employee(std::string_view name, IDType id, double wage) : m_name { name } , m_id { id } , m_wage { wage } { }

    const std::string& getName() { return m_name; }
    IDType getId() { return m_id; }       // 类内直接访问 类型别名
};

int main() {
    Employee john { "John", 1, 45000 };
    Employee::IDType id { john.getId() }; // 类外用 :: 访问类型别名

    std::cout << john.getName() << " has id: " << id << '\n';
}
#+end_src

[fn:3]
#+begin_src cpp :results output :namespaces std :includes <iostream> <string> <string_view>
class Employee {
public:
    using IDType = int;

    class Printer {
    public:
        void print(const Employee& e) const {
            // Printer 不能访问 Employee的 this指针，因此，我们需要传入 Employee对象
            // 因为 Printer 是 Employee 的成员变量，我们可以访问私有成员 m_name、m_id
            std::cout << e.m_name << " has id: " << e.m_id << '\n';
        }
    };
private:
    std::string m_name{};
    IDType m_id{};
    double m_wage{};
public:
    Employee(std::string_view name, IDType id, double wage)
        : m_name{ name }, m_id{ id }, m_wage{ wage }{ }
};

int main() {
    const Employee john{ "John", 1, 45000 };
    const Employee::Printer p{}; // 实例化嵌套类对象
    p.print(john);
}
#+end_src

#+RESULTS:
: John has id: 1

[fn:4]
#+begin_src cpp :results output :namespaces std :includes <iostream>
class outer {
public:
    class inner1;   // okay: 在外部类内 前向声明 inner1
    class inner1{}; // okay: 在外部类内 定义 inner1
    class inner2;   // okay: 在外部类内 前向声明 inner2
};

class inner2 {};    // okay: 在外部类外 定义 inner2

int main() {
    return 0;
}
#+end_src

[fn:5]
#+begin_src cpp :results output :namespaces std :includes <iostream>
class outer;         // okay: can forward declare non-nested type
class outer::inner1; // FIXME 不能在 外部类定义前前向声明

class outer {
public:
    class inner1{};
};

class outer::inner1; // okay (but redundant) since nested type has already been declared as part of outer class definition

int main() {
    return 0;
}
#+end_src

[fn:6]
#+begin_src cpp :results output :namespaces std :includes <iostream>
class Something {
public:
    static int s_value;      // 声明静态变量
};

int Something::s_value{ 1 }; // 类外 定义和初始化 静态变量

int main() {
    Something::s_value = 2;
    std::cout << Something::s_value << '\n';
}
#+end_src

[fn:7]
#+begin_src cpp :results output :namespaces std :includes <iostream>
class Whatever {
public:
    static const int s_value{ 4 };                       // a static const int can be defined and initialized directly
    static inline int s_value{ 4 };                      // a static inline variable can be defined and initialized directly
    static constexpr double s_value{ 2.2 };              // ok
    static constexpr std::string_view s_view{ "Hello" }; // this even works for classes that support constexpr initialization
};
#+end_src
