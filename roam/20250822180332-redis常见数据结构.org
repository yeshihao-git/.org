:PROPERTIES:
:ID:       e815c0a7-1496-4552-8a9f-aad4d4227fed
:END:
#+title: redis面试题
#+filetags: redis

* redis常见5种数据类型
# redis所有数据结构都存储为字符串：文本、整数、浮点数、二进制数据
见：[[id:507f6f4e-7740-42a4-bdf9-4e7a0efba4cd][图:redis的数据类型]]
*String（字符串）*
1. 存储 *单个元素*
2. *使用场景* ：热点数据（用户信息）、临时数据（验证码、登录token等）、常规计数、分布式锁等
3. 底层    ： =简单动态字符串(SDS)= 结构体：内部有个 len字段 用于表示字符串的结束，不同于C风格字符串'\0'
   1) 可以保存 二进制数据（优越点，原因在于 len字段）
   2) 获取字符串长度时间复杂度是 O(1)（优越点，原因在于 len字段）
   3) 不会造成缓冲区溢出：SDS在拼接字符串前会检查SDS空间是否满足要求，不够则扩容（优越点）

*List  （链表）*
1. 存储 *元素序列*
2. *使用场景* ：消息队列（1. 生产者需要实现全局唯一ID； 2. 不能以消费组形式消费数据）
3. 底层    ： =压缩列表= 或 =双向链表= ：元素个数小于512个，每个元素小于64字节，使用压缩列表，否则 双向链表

*Hash  （哈希）*
1. 存储 *k-v 集合*
2. 使用场景：缓存对象、购物车等
3. 底层    ： =压缩列表= 或 =哈希表= ：元素个数小于512个，每个元素小于64字节，使用压缩列表，否则 哈希表

*Set   （集合）*
1. 存储 *无序、不重复* 元素集合
2. 使用场景：聚合计算（并集、交集、差集），eg：点赞、共同关注、抽奖活动等
3. 底层    ： =整数集合= 或 =哈希表= ：元素个数小于512个，使用整数集合，否则 哈希表

*Zset  （有序集合）*
1. 存储 *按分数排序、不重复* 元素集合
2. 使用场景：排序场景，eg：排行榜、电话和姓名排序等
3. 底层    ： =压缩列表= 或 =跳表= ：元素个数小于128个，每个元素小于64字节，使用压缩列表，否则 跳表

** 图:redis的数据类型 :ATTACH:
:PROPERTIES:
:ID:       507f6f4e-7740-42a4-bdf9-4e7a0efba4cd
:END:
[[attachment:_20251110_161048screenshot.png]]


* redis线程模型
*主线程* 采用IO多路复用模型，负责：网络IO、执行命令
后台3个 *辅助线程* ，负责：处理后台任务
- 文件关闭线程  :: 关闭文件描述符                         -> 避免文件关闭操作阻塞主线程，提升主线程处理效率
- AOF刷盘线程   :: 将 AOF缓冲区的数据刷到磁盘中的AOF日志  -> 在保证数据持久化的同时，减少对主线程的阻塞
- lazy free线程 :: 释放大键值对占用的内存                 -> 避免删除大键时因同步释放内存导致主线程阻塞，保障 Redis 响应速度
#+begin_comment
主线程将 耗时操作（文件关闭、AOF 刷盘、大键释放）封装为任务，放入各个辅助线程对应任务队列；辅助线程各自监听专属队列，执行任务
#+end_comment

** redis是单线程为什么还快？
1. 大部分操作在 *内存* 中执行
2. 采用 *IO多路复用模型* ，高效处理多个IO流
3. 单线程模型 *避免多线程竞争*


* redis持久化
持久化就是将内存中的数据保存到硬盘，用于后续从磁盘中恢复数据

*AOF日志*
1. 执行写操作，记录写操作到AOF内存缓冲区，按配置中的AOF写回策略（[[id:2712bd3a-dcc9-4e58-848b-f3071a223f16][图:AOF日志写回策略]]）定期刷到磁盘的AOF日志文件里；具体见：[[id:8c69d532-2c56-42ad-81eb-ae4893170435][图:AOF日志]]
2. 恢复数据时，读取磁盘中的AOF日志文件，逐行执行里面的写操作，恢复数据慢（全量恢复时所有日志中的所有命令，逐一执行）

*RDB快照*
记录某一瞬间内存中的数据，恢复数据快（直接加载就行，无需执行命令）；但是频率太低，丢失数据多，频率太高，影响性能

*混合持久化*
=混合持久化的AOF文件 = RDB格式数据 + AOF格式增量操作=
- 前半段 RDB格式数据    ：使得 redis 启动更快（RDB优点）
- 后半段 AOF格式增量操作：减少大量数据丢失风险（AOF优点）

** 图:AOF日志写回策略 :ATTACH:
:PROPERTIES:
:ID:       2712bd3a-dcc9-4e58-848b-f3071a223f16
:END:
即写回硬盘的策略，在 Redis.conf 中的 appendfsync配置项 有以下3钟参数可填：
[[attachment:_20251110_171020screenshot.png]]

** 图:AOF日志 :ATTACH:
:PROPERTIES:
:ID:       8c69d532-2c56-42ad-81eb-ae4893170435
:END:
[[attachment:_20250830_164507screenshot.png]]
1. redis执行写命令后，将命令追加到 server_aof_buf 缓冲区
2. 通过 write()系统调用 将 aof_buf缓冲区数据写入 AOF文件，然后拷贝 内核缓冲区的 [[id:5007d3f1-963b-48d3-88ff-261c4b4e454e][PageCache]]，等待内核将数据写入磁盘
3. 具体什么时候写入磁盘，由 redis的3种写回策略决定


* TODO redis如何实现服务高可用？
基于3个机制：
1. 主从复制
2. 哨兵模式
3. 切片集群

*主从复制* ：
1. 主服务器处理客户端写操作，并同步到从服务器；客户端可以从主服务器和从服务器进行读操作
2. 用于 数据备份、读写分离

*哨兵模式* ：
1. 用于 主从节点故障转移

*切片集群（redis cluster）*  ：
1. 一个切片集群有 16384个哈希槽（类似于数据分区），每个redis节点对应部分哈希槽，数据的key按照CRC16算法计算后再对 16384取模，映射到对应的哈希槽，再从哈希槽映射到对应的redis节点
2. 用于 减少系统对单个主节点依赖、灵活扩容
   - 减少系统对单个主节点依赖 :: 数据是分散到多个主节点的：1. 单个主节点资源压力（CPU、内存）小很多 2. 某个主节点故障，只影响它负责的数据
   - 灵活扩容                 :: 新增主节点只需要重新分配哈希槽，无需停止服务，缩容同理


* TODO redis过期删除策略
每当我们对key设置过期时间，则key、过期时间会被存储到 *过期字典* ：查询key时，先看 过期字典，若不存在则正常读取键值；若存在则读取key的过期时间，判断是否过期，若过期则使用某种 *过期删除策略*

*过期删除策略* ：redis 使用 惰性删除+定期删除
- 惰性删除 :: 不主动删除，每次访问key时，检测key是否过期，若过期则删除 -> 对CPU时间友好，对内存不友好
  #+begin_comment
  对CPU友好   ：每次访问key时，才检查key是否过期
  对内存不友好：若key过期，但一直没被访问，则一直占用内存
  #+end_comment
- 定期删除 :: 每隔一段时间 随机从数据库取出一定数量的key进行检查，删除过期key -> 对内存时间友好，对CPU不友好
  #+begin_comment 流程
  1. 过期字典中随机抽N个key，检查是否过期，过期则删除
  2. 若本次检查的key里超过 25% 过期，则重复 1.；否则停止
  #+end_comment

*持久化时，过期键处理策略* ：
RDB：
1. RDB文件生成：过期key不会保存到RDB文件
2. RDB文件加载：
   主服务器 -> 不会加载过期key
   从服务器 -> 无论是否过期都加载，后续从主服务器同步数据

AOF：
1. AOF文件写入：过期key未被删除，写入AOF文件，当过期key删除后，redis向AOF文件追加一条DEL命令显式删除
2. AOF重写：不会保存 过期key 到重写后的AOF文件

*主从模式，过期键处理策略* ：同上边RDB文件加载的处理方式


* TODO redis内存淘汰策略
- noeviction      :: （redis3.0后默认）运行内存超过最大设置内存时，不淘汰数据，直接返回错误

设置过期时间的数据范围内淘汰
- volatile-random :: 随机淘汰
- volatile-ttl    :: 淘汰最早过期
- volatile-lru    :: （redis3.0前默认）淘汰最久未使用
- volatile-lfu    :: （redis3.0后新增）淘汰最少使用

所有数据范围内淘汰
- allkeys-random  :: 随机淘汰
- allkeys-lru     :: 淘汰最久未使用
- allkeys-lfu     :: 淘汰最少使用

*LRU*
*LFU*


* 缓存雪崩、缓存击穿、缓存穿透
*缓存雪崩*
1. 大量缓存数据同一时间过期；此时大量用户请求redis无法处理，导致数据库压力骤增，严重可能导致数据库宕机
2. 解决：
   1) 缓存随机失效时间
   2) 设置缓存不过期

*缓存击穿*
1. 某个热点缓存数据过期
2. 解决：
   1) 设置热点数据缓存不过期
   2) 互斥锁？

*缓存穿透*
1. 用户访问的数据既不在缓存也不在数据库（缓存雪崩、缓存击穿 因为数据库有数据，可以通过恢复缓存来减少数据库压力，缓存 穿透则不行）
2. 解决：
   1) 缓存中设置 空值 或 默认值
   2) 非法请求限制？
   3) 布隆过滤器？


* 缓存更新策略
常见3种：
1. Cache Aside（旁路缓存）
2. Read/Write Through（读穿/写穿）
3. Write Back（写回）

*Cache Aside（旁路缓存）*
- 读策略   :: 读缓存，存在则返回；否则，读数据库回写缓存，返回结果
- 写策略   :: 写数据库，删缓存
------------------------------------------------------------------
- 适用场景 :: 读多写少；不适合写多的场景

*Read/Write Through（读穿/写穿）*
应用程序只跟缓存交互，由缓存充当“代理”与数据库交互
- 读穿 :: 读缓存，存在则返回；否则缓存查数据库回写缓存，返回结果
- 写穿 :: 缓存中有数据，则更新缓存，由缓存写数据库；否则，更新数据库，返回

*Write Back（写回）*
只写缓存，缓存异步批量同步数据库


* TODO 用redis实现一个分布式锁
