:PROPERTIES:
:ID:       15357ed3-3530-4c07-b743-9af983e05e96
:END:
#+title: 类型别名
#+filetags: cpp

* 类型别名
- 类型别名 :: 为现有类型创建新名称，两种方式： [[id:1e55a2a9-995a-4852-848d-809a2a16e150][using]] 和 [[id:10852082-7575-4edd-b930-161e525982c1][typedef]]
#+begin_src cpp
using 别名 = 原类型;  // 现代 C++ 风格（推荐）
typedef 原类型 别名;  // 古代 C 风格

using FcnType = int(*)(double, char); // 可读性更好，FcnType 容易找到
typedef int (*FcnType)(double, char);
#+end_src

*如何使用？* [fn:1]
1. 平台无关编码，适配不同平台（eg：[[id:7a92e820-74d8-4e75-ae81-d6caa7010598][固定宽度整数类型]]）
2. 简化复杂类型
3. 值的语义更清晰
4. 便于代码维护：一处修改，处处生效

** typedef
:PROPERTIES:
:ID:       10852082-7575-4edd-b930-161e525982c1
:END:
- typedef :: 古代 C 风格的类型别名方法
#+begin_example cpp
typedef 原类型 别名;
#+end_example


** using
:PROPERTIES:
:ID:       1e55a2a9-995a-4852-848d-809a2a16e150
:END:
- using :: （cpp11）现代 C++ 风格的类型别名方法
#+begin_example cpp
using 别名 = 原类型;
#+end_example

*最佳实践*
1. 优先使用限定名称（eg：std::cout）
2. .cpp文件 中有限使用 using声明
3. 避免使用 using指示（除非测试代码中）

*** using声明
:PROPERTIES:
:ID:       43588f09-c7d7-4c7a-9e13-026c2dda6441
:END:
- using声明 :: 将命名空间中的 *名称导入当前作用域* ，使用非限定名称访问
  1. 导入后可参与 [[id:a545a441-471f-45d4-8a7b-30767486357a][函数重载]] [fn:2]
#+begin_src cpp
using <命名空间>::<名称> // NOTE 语法

using std::cout;
cout << "Hello";
#+end_src

- 限定名称   :: 使用 =作用域解析运算符（::）= 将名称和命名空间关联的名称
- 非限定名称 :: 名称和命名空间没有关联的名称
#+begin_src cpp
std::cout // 限定名称
cout      // 非限定名称
#+end_src

*** using指示
:PROPERTIES:
:ID:       07ec9a97-a6ed-4ab8-bc3b-8569b39604f7
:END:
- using指示 :: 将命名空间中的名称全部导入当前作用域，通过非限定名称访问全部内容： =using namespace <命名空间>=
#+begin_src cpp
using namespace std; // 之后可直接用 cout、cin 等
cout << "Hello";
#+end_src


* 固定宽度整数类型
:PROPERTIES:
:ID:       7a92e820-74d8-4e75-ae81-d6caa7010598
:ROAM_ALIASES: "int8_t int16_t int32_t"
:END:
- 固定宽度整数类型 :: （cpp11）能保证在任何平台都具有精确比特数的整数类型，解决 int/long 等类型宽度随平台变化的问题（cpp标准只限定int最小大小，没限定实际大小）。 *本质* 上是现有类型的 [[id:15357ed3-3530-4c07-b743-9af983e05e96][类型别名]]
#+begin_example cpp
std::int#_t     // 有符号
std::uint#_t    // 无符号
// # 为位数（8、16、32、64）
#+end_example

*如何使用？*
1. int范围不重要：int（eg：年龄）
2. int范围重要  ：固定宽度类型


* std::size_t
:PROPERTIES:
:ID:       47655043-8c9b-4104-95ad-4c872ed3e7b8
:END:
- std::size_t :: 用于表示 *系统最大对象大小* / *数组索引* 的 *无符号整数类型别名* （足够容纳当前系统任意对象的字节大小），通常是 =unsigned long= 或 =unsigned long long=



* Footnotes

[fn:1]
#+name: 平台无关编码
#+begin_src cpp
#ifdef INT_2_BYTES
  using int32_t = long;  // 2字节平台
#else
  using int32_t = int;   // 4字节平台
#endif
#+end_src

#+name: 简化复杂类型
#+begin_src cpp
using VectPairSI = std::vector<std::pair<std::string, int>>; // make VectPairSI an alias for this crazy type
bool hasDuplicates(VectPairSI pairlist) // use VectPairSI in a function parameter
{
  // some code here
  return false;
}
int main()
{
  VectPairSI pairlist; // instantiate a VectPairSI variable
  return 0;
}
#+end_src

#+name: 值的语义更清晰
#+begin_src cpp
using TestScore = int;
TestScore gradeTest(); // 若这里返回 int，则不知道返回的是啥
#+end_src

#+name: 便于代码维护
#+begin_src cpp
using StudentId = long;  // 只需修改此处的 long，所有使用 StudentId 的地方都会生效
#+end_src

[fn:2]
#+begin_src cpp :results output :namespaces std :includes <iostream>
class Base {
public:
    void print(int)    { std::cout << "Base::print(int)\n"; }
    void print(double) { std::cout << "Base::print(double)\n"; }
};

class Derived: public Base {
public:
    using Base::print; // 将基类的print加入派生类作用域，使其可以参与 函数重载解析
    void print(double) { std::cout << "Derived::print(double)"; }
};

int main() {
    Derived d{};
    // 参数是int，我们希望调用 Base::print(int)，若没有使用using，则会调用 Derived::print(double)
    d.print(5); // 调用Base::print(int)
}
#+end_src

#+RESULTS:
: Base::print(int)
