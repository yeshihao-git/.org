:PROPERTIES:
:ID:       bee683d2-eec4-45a8-af02-be369d182e8d
:END:
#+title: 类型推导
#+filetags: cpp

* auto
:PROPERTIES:
:ID:       34e240af-6e94-437c-a675-d0bc6ed31137
:END:
- auto :: （cpp11） 根据初始化表达式推导类型，会执行表达式，丢弃[[id:d9781d23-ff8a-4e3e-a677-932461947130][顶层const]]和[[id:1f772bce-0f88-46a2-ab44-c9bf04b30653][引用]]
  1. *顶层const、引用 会被丢弃* ，需要重新添加 顶层const、引用 以保留 [fn:1]
  2. =auto&= 推导 =const T&= 的值，则 推导类型为 =const auto&= [fn:2]
  3. *[[id:b06260e2-ed7a-4b12-8e9d-b07a3e564a75][constexpr]] 含有隐式的 const* 且会被丢弃，需要重新添加 constexpr 以保留 [fn:1]
  4. auto 用于 *后置返回类型语法* 时，只作为语法的一部分，不进行类型推导 [fn:3]


* decltype
:PROPERTIES:
:ID:       e21bd4d5-a73f-4802-af0d-414f9b2fa13c
:END:
- decltype :: （cpp11）编译时推导表达式类型，不执行表达式，保留类型修饰（顶层const、引用）


* Footnotes

[fn:1]
#+begin_src cpp :results output :namespaces std :includes <iostream>
constexpr double a { 3.4 };  // const double (constexpr 不是类型的一部分, const 是隐式的，const是类型限定符，因此是类型的一部分，推导出 const double)

auto b { a };                // double (const 丢弃)
const auto c { a };          // const double (const 丢弃又添加)
constexpr auto d { a };      // const double (const 丢弃又被 constexpr 隐式添加)
#+end_src

[fn:2]
#+begin_src cpp
const std::string& getConstRef();

int main() {
    auto ref1{ getConstRef() };  // std::string (引用丢弃 -> 底层const 变 顶层const -> 丢弃 顶层const)
    auto& ref2{ getConstRef() }; // const std::string& (添加了引用，因此 底层const 没有变成 顶层const -> 底层const 没有被丢弃)
}
#+end_src

[fn:3]
#+begin_src cpp
std::common_type_t<int, double> compare(int, double);         // 难以阅读
auto compare(int, double) -> std::common_type_t<int, double>; // 易读

// 其他示例
auto add(int x, int y) -> int;
auto divide(double x, double y) -> double;
auto printSomething() -> void;
auto generateSubstring(const std::string &s, int start, int len) -> std::string;
#+end_src

