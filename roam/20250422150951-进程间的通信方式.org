:PROPERTIES:
:ID:       eea0107c-ac34-4210-be33-534585e20915
:END:
#+title: 进程间的通信方式
#+filetags: 进程

* 进程间的通信方式
** 管道
:PROPERTIES:
:ID:       8aedbff1-d9b1-4e40-8ef6-af3319ca76b9
:END:
- 管道 :: 本质是操作系统管理的内核空间的内存中的 *缓冲区* ，通过暴露两个文件描述符，让进程可以对这块缓冲区读写，实现进程间通信；分为：匿名管道、命名管道
  + 匿名管道 :: 通过 =int pipe(int fd[2])= 创建 代表读端（ =fd[0]= ）和写端（ =fd[1]= ）的文件描述符实现通信，用于 *血缘关系进程间通信*
     #+begin_comment 具体做法
     父进程调用 =fork()= 创建子进程，子进程会复制父进程的文件描述符，一端使用读，另一端使用写
     #+end_comment

  + 命名管道 :: 通过创建 =类型为管道的设备文件= 进行通信，进程只要使用这个文件就能实现通信，用于 *任意进程间的通信*

*优缺点* ：
1. 没有消息边界，需要消息解析逻辑（管道是面向字节流的）
2. 用户态内核态数据拷贝开销、状态转换开销（系统调用 + 缓冲区在内核）
   # 管道    ：进程A产生数据 -> 数据拷贝（用户态 -> 内核态） -> 数据拷贝（内核态 -> 用户态）-> 数据B接收数据 [两次拷贝]
   # 共享内存：进程A产生数据 -> 数据B接收数据


** 消息队列
:PROPERTIES:
:ID:       a7007bf8-4a12-495e-a223-e6520f4091ae
:END:
- 消息队列 :: 本质是操作系统管理的内核空间的内存中的 *消息链表* ，是一种异步通信的机制，能够解耦发送方和接收方（发送者将消息放到队列就能返回，无需等待接收方）

*优缺点* ：
1. [改进] 解决了 管道 中的消息边界问题
2. 用户态内核态数据拷贝开销、状态转换开销（系统调用 + 缓冲区在内核）
3. 通信不及时（系统调用 + 缓冲区在内核）
   # 消息队列：发送方 将数据放到队列，接收方 需要从队列中取
   # 共享内存：发送方 将数据放入共享内存，接收方无需取


** 共享内存
:PROPERTIES:
:ID:       834eebf7-d5c5-4d6f-ba1e-7a1648658d67
:END:
- 共享内存 :: 多个进程的虚拟内存地址 映射到 同一物理内存

*优缺点* ：
1. [改进] 无用户态内核态数据拷贝开销、状态转换开销
2. [改进] 通信最快
3. 缺少同步机制，可能数据混乱


** 信号量
:PROPERTIES:
:ID:       2e1ef9a6-bb66-4d84-83b8-2b19954b46e0
:END:
- 信号量 :: 本质是一个 *整数* ，表示资源的数量，通过 *PV操作* 实现进程间 *互斥* 和 *同步* [fn:1]
  1. 信号量是 *"万能工具"* ，可以实现 所有的[[id:ac8c9c6d-760b-4ec8-847b-cbedebee7085][锁]]和条件变量（也就是能实现 互斥、同步）
  2. P操作： =信号量-1= ，P后信号量<0 ，阻塞（说明资源已经被占用）
  3. V操作： =信号量+1= ，V后信号量<=0，唤醒队首进程（说明有进程被阻塞）
  4. 互斥 ： =初始信号量=1=
  5. 同步 ： =初始信号量=0=



** 信号
:PROPERTIES:
:ID:       b9bc040d-beda-4370-a511-11d5e54c0c79
:END:
- 信号 :: 操作系统向进程发送的异步通知，通知进程发生了某个事件（如：中断、挂起、终止等。[[id:ec7aef91-2628-4ba9-b300-16652314877f][linux]]中使用 kill命令 发送信号），进程处理方式：
  1. 执行信号默认操作
  2. 捕获信号，执行自定义操作
  3. 忽略信号


** Socket
- Socket :: （套接字）用于在 同一/不同网络 的进程之间通信


* Footnotes

[fn:1]
#+begin_src c
struct semaphore {
    int count;              // 当前可用资源数
    queue wait_queue;       // 阻塞进程的等待队列
};

void P(semaphore S) {
    S.count--;              // 尝试占用资源
    if (S.count < 0) {      // 资源不足
        // 将当前进程加入等待队列
        enqueue(S.wait_queue, current_process);
        block(current_process); // 阻塞进程
    }
}

void V(semaphore S) {
    S.count++;              // 释放资源
    if (S.count <= 0) {     // 有进程在等待
        // 从等待队列唤醒一个进程
        process = dequeue(S.wait_queue);
        wakeup(process);    // 唤醒进程
    }
}
#+end_src
