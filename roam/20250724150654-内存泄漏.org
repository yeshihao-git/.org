:PROPERTIES:
:ID:       6782179f-792b-4eb6-807c-4f95aba88169
:END:
#+title: 内存泄漏
#+filetags: cpp

* 内存泄漏
** 原因
1. 指针 超出作用域
#+begin_src cpp
void doSomething()
{
    int* ptr{ new int{} };
}
#+end_src

2. 指针 更改指向
#+begin_src cpp
int value = 5;
int* ptr{ new int{} }; // 分配内存
ptr = &value;          // 旧地址丢失 -> 内存泄漏
#+end_src

3. 为 指针 重新分配内存
#+begin_src cpp
int* ptr{ new int{} };
ptr = new int{};       // 旧地址丢失 -> 内存泄漏
#+end_src

4. 析构函数没有设置为虚析构，直接 delete 基类指针 [fn:1]

** 排查
1. top查看内存是否持续增长
2. 多次重复操作（如多次调用某功能），内存增长加快
3. Valgrind 检查 HEAP SUMMARY

** 预防
1. *RAII* ：用类的生命周期自动管理资源：构造函数中分配资源，析构函数中释放资源
2. [[id:7cb0d4aa-e74a-4563-acf6-053e129105e9][智能指针]]

* Footnotes

[fn:1]
#+begin_src cpp :results output :namespaces std :includes <iostream>
class Base {
public:
    ~Base() { // note: not virtual
        std::cout << "Calling ~Base()\n";
    }
};

class Derived: public Base {
private:
    int* m_array {};

public:
    Derived(int length) : m_array{ new int[length] } { }

    ~Derived() { // note: not virtual (your compiler may warn you about this)
        std::cout << "Calling ~Derived()\n";
        delete[] m_array;
    }
};

int main() {
    Derived* derived { new Derived(5) };
    Base* base { derived };

    delete base;
}
#+end_src
