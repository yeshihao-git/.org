:PROPERTIES:
:ID:       ac8c9c6d-760b-4ec8-847b-cbedebee7085
:END:
#+title: 锁
#+filetags: os

* 锁
- 锁 :: 实现 *互斥访问* （实现同步 条件变量）。两个最基本的锁，很多高级锁基于它们实现：
  + 互斥锁 :: 访问共享资源前加锁，访问结束解锁，资源被锁期间，任何试图再对资源加锁的线程都会 *被阻塞，释放CPU* ，直到加锁线程释放锁，加锁失败导致的 内核态/用户态切换 以及 加锁失败线程的状态切换，存在一定性能开销，因此互斥锁适合 *锁持有时间较长* 的情况
  + 自旋锁 :: 类似互斥锁，但加锁失败不会被阻塞，线程处于 *忙等待状态，一直持有CPU* ，性能开销较小，因此自旋锁适合 *锁持有时间较短，不希望线程调度产生开销* 的情况

*互斥锁、自旋锁 实现*
1. [[id:97bd56c8-5092-4ef3-95db-c18e3c1b3be1][Test-and-Set]]
2. CAS（Compare-And-Swap）


** Test-and-Set
:PROPERTIES:
:ID:       97bd56c8-5092-4ef3-95db-c18e3c1b3be1
:END:
#+name: TAS
#+begin_src c
int TestAndSet(int *old_ptr, int new) {   // 原子指令：old_ptr 更新为 new 的新值（更新新值），返回 old_ptr 的旧值（测试旧值）
  int old = *old_ptr;
  *old_ptr = new;
  return old;
}
#+end_src

#+name: TAS实现 忙等待锁
#+begin_src c
typedef struct lock_t {
  int flag;
} lock_t;

void init(lock_t *lock) {
  lock->flag = 0;         // 0 代表锁没有被持有
}

// 加锁函数
// 场景1加锁成功：当前线程调用 lock()，此时没有其他线程持有锁，TestAndSet返回0，跳过while循环（不会被阻塞），同时flag设置为1（表示取到锁），结束 lock()
// 场景2加锁失败：当前线程调用 lock()，此时其他线程持有锁，TestAndSet返回1，同时不断设置flag为1，当前线程一直卡在while循环（阻塞），当其他线程调用 unlock() 重新将flag设为0，卡在while循环的当前线程TestAndSet返回0，跳过while循环（不会被阻塞），同时flag设置为1（表示取到锁），结束 lock()
 void lock(lock_t *lock) {
  while (TestAndSet(&lock->flag, 1) == 1)
    ; // do nothing
}

void unlock(lock_t *lock) {
  lock->flag = 0;
}
#+end_src

#+name: TAS实现 无等待锁
#+begin_src c
typedef struct lock_t {
  int flag;
  queue_t *q; // 等待队列
} lock_t;

void init(lock_t *lock) {
  lock->flag = 0;         // 0 表示锁没有被持有
  queue_init(lock->q);    // 初始化 等待队列
}

void lock(lock_t *lock) {
  while(TestAndSet(&lock->flag, 1) == 1) {
    1. 保存 现在运行线程的 TCB;
    2. 将 TCB 插入等待队列;
    3. 设置线程为 等待状态;
    4. 调度程序;
  }
}

void unlock(lock_t *lock) {
  if (lock->q != NULL) {
    1. 移出 等待队列的队头元素;
    2. 将 线程TCB 插入 就绪队列;
    3. 设置线程为 就绪状态;
  }

  lock->flag = 0;
}
#+end_src
