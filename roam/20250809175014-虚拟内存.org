:PROPERTIES:
:ID:       9c2a5102-40ec-47c9-ae2f-ea3b8c7b2df9
:END:
#+title: 虚拟内存
#+filetags: os

* 为什么要有虚拟内存？
1. *安全* ：虚拟内存是进程和物理内存中的一层，进程通过虚拟内存地址访问物理内存，而 *虚拟内存地址到物理内存地址的映射是由操作系统完成* 的， *操作系统会保证访问不越界* ；现代操作系统通常是多进程的，如果没有虚拟内存，进程可以随意访问物理内存，可能导致程序崩溃 ->  *实现方式* ： =CPU 中的 MMU、TLB、页表= 协作完成
   #+begin_example 没有虚拟内存的情况？
   单进程情况：程序1对物理内存的任意地址读写都没问题
   多进程情况：程序1在物理内存的地址2000写入新值，程序2又在地址2000写入其他内容
   #+end_example
2. *效率* ：根据 局部性原理 我们可以得出结论，程序要运行，无需完整装入内存，只需要装所需的部分，其他部分按需装入或换出 ->  *实现方式* ： =虚拟内存 请求调页 、页面置换 机制=
   - 局部性原理 ::
     时间局部性：程序访问某条指令/数据后，不久将再次访问
     空间局部性：程序访问某个存储单元后，附近存储单元很可能被访问
   #+begin_example 没有虚拟内存的情况？
   程序太大，装不进内容，无法运行
   程序太多，只能运行部分，并发度下降
   程序结束前一直驻留内存，浪费内存，并发度下降（程序要运行 只需要部分所需的内容）
   #+end_example


* 虚拟/物理内存的映射方式

📎：[[[https://xiaolincoding.com/os/3_memory/vmem.html#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98][小林coding]]]

** 内存分段
1. 按 *逻辑* 将（虚拟/物理）内存分段（程序：代码段、数据段、堆段、栈段 的逻辑）
2. *流程* ：CPU将 虚拟内存地址 交给 内存管理单元（MMU），由 MMU 查询 段表 找到 物理内存地址； *具体来说* ：虚拟内存地址分为 =段选择因子= 、 =段内偏移量= ，首先从段选择因子中找到段号，根据段号找到段表中的某一项，段表项中有 =段基地址= 、 =段界限= ，根据段基地址找到物理内存段起始位置，再和虚拟地址的段内偏移量计算得到最终物理内存地址，段界限用于判断内存访问是否越界；见：[[id:af60416a-d043-43ed-96b0-c6fbcb9040ad][图:段表及工作原理]]
3. *存在的问题* ：
   1) 外部碎片（段之间有间隙）
      #+begin_example
      3个程序运行，1个程序结束从内存换出，剩余2个程序的段之间出现空隙，第4个程序无法放入这些间隙中，产生了外部碎片
      #+end_example
   2) 内存交换效率低（要将整个从内存交换到硬盘）


*** 🖼 段表及工作原理 :ATTACH:
:PROPERTIES:
:ID:       af60416a-d043-43ed-96b0-c6fbcb9040ad
:END:
[[attachment:_20250822_094429screenshot.png]]


** 内存分页(🔥重点)
1. 按 *固定大小* 划分（虚拟/物理）内存
   - 这个固定大小内存称为 *页* ，linux 中页为 4KB
   - 解决内存分段 外部内存碎片（页之间紧密排列）、内存交换效率低（按页交换） 的问题

2. *单级页表流程* ：CPU将 虚拟内存地址 交给 MMU，MMU 查 TLB 若缓冲命中直接返回，否则查询 页表 找到 物理内存地址； *具体来说* ：虚拟内存地址分为页号和页内偏移量，根据页号可以找到对应页表项，页表项中有虚拟页号和物理页号的映射关系，根据物理页号和虚拟内存地址中的页内偏移量找到最终物理内存地址；见：[[id:73c88c8b-35ce-4497-8a15-93d0397b17e5][图:页表及工作原理]] *存在的问题* ：占用内存空间大 -> 页表需要记录进程完整的内存映射关系 -> 若进程数量很多，则页表在内存中占用就会很大

3. *多级页表流程* ：将虚拟内存中的页号分为一级页号、二级页号（对应一级页表和二级页表），CPU将 虚拟内存地址 交给 MMU，MMU 查 TLB 若缓冲命中直接返回，否则先查询 一级页表，根据 一级页号 找到 二级页表地址，再根据二级页号找到物理页号，最后根据物理页号和虚拟内存地址中的页内偏移量找到最终物理内存地址；见：[[id:4f2750df-0519-4de9-b3f5-7e24aeba8a45][图:多级页表及工作原理]]
   1) 页表内存占用少：一级页表覆盖完整内存映射（每个一级页表项表示的范围更大），二级页表按需创建（由于局部性原理，只需要创建部分的二级页表）
      #+begin_comment
      单级页表不能这样做，因为必须要有完整的内存映射，否则就查不到，多级页表中一级页表覆盖完整的内存映射了
      #+end_comment
   2) 查询更快：
      #+begin_example
      从100本书中找到某本书中的一页
      单级页表：在100本书中的所有目录中找
      多级页表：先在100本书目录中找到那本书，再去书的目录中找那一页
      #+end_example

4. *TLB（快表、页表缓存）* ：缓存最常访问的页表项（局部性原理），缓存命中直接返回； *具体来说* ：CPU 将虚拟内存地址 交给 MMU，MMU 查询 TLB，命中则直接使用缓存的页表项，否则常规页表查询


*** 🖼 页表及工作原理 :ATTACH:
:PROPERTIES:
:ID:       73c88c8b-35ce-4497-8a15-93d0397b17e5
:END:
[[attachment:_20250822_101140screenshot.png]]


*** 🖼 多级页表及工作原理 :ATTACH:
:PROPERTIES:
:ID:       4f2750df-0519-4de9-b3f5-7e24aeba8a45
:END:
[[attachment:_20250822_103804screenshot.png]]


*** 🖼 TLB、MMU工作原理 :ATTACH:
:PROPERTIES:
:ID:       a6223d1f-9896-48c0-ae64-f108eb98fa3b
:END:
[[attachment:_20250822_105410screenshot.png]]


** 段页式内存
1. 将内存按逻辑分段，再将每个段分页；根据段表找到页表，根据页表找到对应物理页号


*** 🖼 段页式工作原理 :ATTACH:
:PROPERTIES:
:ID:       1a322d7b-fa42-4a42-8e6e-3200a0b79056
:END:
[[attachment:_20250822_110942screenshot.png]]


* 请求调页（图文） :ATTACH:
:PROPERTIES:
:ID:       37818a8d-725a-424d-8b37-9c491adc66ed
:END:
[[attachment:_20250809_195613screenshot.png]]
*流程* ：访问页表时，页表项中的物理页号无效，CPU 发出缺页中断，从磁盘加载页面到物理内存（若没有空闲页，则选择一个物理页换出 -> [[id:c4463c71-680f-449b-8da5-5853633e3a18][页面置换算法]]），修改页表项的状态位


* 页面置换算法
:PROPERTIES:
:ID:       c4463c71-680f-449b-8da5-5853633e3a18
:END:
|-----------------------+-------------------------------------------------------------------------------------+----------------------------|
| 算法                  | 淘汰页面规则                                                                        | 优缺点                     |
|-----------------------+-------------------------------------------------------------------------------------+----------------------------|
| OPT（[[id:f480d6bf-da5d-4fd9-a433-f1c12a1c21cf][最佳置换]]）       | 未来最长时间不访问的页面                                                            | 性能最好；无法实现         |
| FIFO（[[id:fd6d25d6-e11e-4ddc-9210-da084b16046c][先进先出]]）      | 最先进入内存的页面                                                                  | 实现简单；Belady 异常      |
| LRU（[[id:030cfed8-79d0-43cd-9e4d-de5cedef7e63][最近最久未使用]]） | 最近一段时间内，最久没访问过的页面                                                  | 性能很好；实现复杂         |
| Clock（[[id:4021ceb2-57e1-4dcb-ba1d-7f614c5ad54c][时钟置换]]）     | 将页面放到一个环形链表中，每个页面访问位设置为1，指针指向最老的页面                 | 高效简单（综合 FIFO、LRU） |
|                       | 发生缺页中断时，检查指针指向页面：访问位为0，则淘汰换入新页面，指针移动到下一个位置 |                            |
|                       | 访问位是1则归0，指针移动到下一个位置，直到找到访问位为0的页面淘汰                   |                            |
| LFU（最少使用）       | 最近一段时间内，访问次数最少的页面                                                  | 实现复杂                   |
|-----------------------+-------------------------------------------------------------------------------------+----------------------------|
#+begin_comment 小咪示例
小咪被评为「最佳」小咪，拥有厕所「先进先出」特权，小咪需要 「最近最久未使用」的厕纸，此时厕所外的臭咪在敲门，小咪看了下「时钟」，拿出了「最不常用」的湿纸巾...
#+end_comment

📎 [[https://www.bilibili.com/video/BV1YE411D7nH?spm_id_from=333.788.videopod.sections&vd_source=4441bc96046659b39d059d583f36ff52&p=57][bilibili-王道]]


** 🖼 最佳页面置换算法 :ATTACH:
:PROPERTIES:
:ID:       f480d6bf-da5d-4fd9-a433-f1c12a1c21cf
:END:
[[attachment:_20250809_201423screenshot.png]]


** 🖼 先进先出页面置换算法 :ATTACH:
:PROPERTIES:
:ID:       fd6d25d6-e11e-4ddc-9210-da084b16046c
:END:
[[attachment:_20250809_201601screenshot.png]]


** 🖼 最近最久未使用页面置换算法 :ATTACH:
:PROPERTIES:
:ID:       030cfed8-79d0-43cd-9e4d-de5cedef7e63
:END:
[[attachment:_20250809_201809screenshot.png]]


** 🖼 时钟页面置换算法 :ATTACH:
:PROPERTIES:
:ID:       4021ceb2-57e1-4dcb-ba1d-7f614c5ad54c
:END:
[[attachment:_20250919_143842screenshot.png]]
