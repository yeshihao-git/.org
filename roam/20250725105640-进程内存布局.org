:PROPERTIES:
:ID:       ae7fc8d9-0053-45b6-92f4-9a42f1565718
:ROAM_ALIASES: cpp程序内存布局
:END:
#+title: C++程序内存布局
#+filetags: cpp

* C++程序内存布局
- C++程序内存布局 :: 代码验证 [fn:1]
  1. [[id:b801ba90-914f-4b99-adf3-4cfc434452ab][栈]]（stack）        ：函数形参、局部变量...
  2. 内存映射段         ：共享内存（内核中的）、动态库（在磁盘中被加载到内存映射段里）、文件映射（将文件映射到进程空间 -> 实现高效的文件IO操作）
  3. [[id:b6a06a10-6ae8-4e39-ab66-beea8919d57d][堆]]（heap）         ：动态分配的内存
  4. BSS段（.bss）      ：（未初始化）全局变量、static变量，[[id:f4a757af-96df-44bc-abef-4720a0c40275][main()]]之前初始化为 0
  5. 数据段（.data）    ：（初始化）  全局变量、static变量
  6. 代码段（.text）    ：
     1. 文本区（编译后的 *机器指令* ）
     2. 只读存储区（[[id:77c81947-ba5c-4bad-93da-03bb11cee093][常量]]）
#+begin_comment
高地址
┌───────────────────────┐
│        Kernel Space   │  （用户态不可访问）
├───────────────────────┤
│        Stack          │  （向下增长）
├───────────────────────┤
│        Memory Mapping │ ←（向上增长）
├───────────────────────┤
│        Heap           │  （向上增长，动态分配内存）
├───────────────────────┤
│        BSS            │  （未初始化：全局变量、static变量）
├───────────────────────┤
│        Data           │  （已初始化：全局变量、static变量）
├───────────────────────┤
│        Text           │  （机器指令、常量）
└───────────────────────┘
低地址
#+end_comment


** 调用栈
:PROPERTIES:
:ID:       b801ba90-914f-4b99-adf3-4cfc434452ab
:END:
- 调用栈 :: 程序运行时在栈内存中的栈结构，记录了 *当前程序的函数调用层级* ，每个被调用的函数以 *栈帧* 的形式存在调用栈中，在栈上 *分配内存的速度较快* ，栈帧 包含：
  1. 函参
  2. 局部变量
  3. 返回地址（CPU 在函数调用结束后通过这个地址返回）
  4. 一些寄存器（调用上下文）

*工作流程*
1. 遇到调用函数，系统 *创建栈帧压入调用栈*
2. CPU 跳转到函数起始点
3. 执行函数内部指令
4. 函数执行结束，从 栈帧 恢复寄存器
5. 弹出栈帧（这会释放所有局部变量、函数参数）
6. CPU 根据返回地址跳回原函数 继续执行
7. 处理返回值

*栈溢出的场景*
1. 递归调用
2. 栈上分配的过多的变量
#+begin_src cpp :results output :namespaces std :includes <iostream>
int main() {
    int stack[10000000];           // FIXME 在栈上分配了一个巨大的数组，栈溢出
    std::cout << "hi" << stack[0]; // 使用了 stack[0]，编译器不会优化数组
}
#+end_src


** 堆
:PROPERTIES:
:ID:       b6a06a10-6ae8-4e39-ab66-beea8919d57d
:END:
- 堆 :: 程序员手动分配的动态内存区域（数据结构：基于完全二叉树实现的优先队列结构）


*** new
:PROPERTIES:
:ID:       53742976-150f-42a6-968b-fc7d694908db
:END:
- new :: C++运算符，在[[id:b6a06a10-6ae8-4e39-ab66-beea8919d57d][堆]]上动态分配内存，自动调用[[id:50402d44-720e-42ed-b590-2b18d219acc1][构造函数]]，返回指向该对象（具有[[id:48f60537-4554-4d24-98fb-65f8a3bbbcf6][动态存储期]]）的指针
  1. =new[]= 用于 *创建动态数组* ，堆上动态分配数组内存，调用数组中每个元素构造函数。长度不需要为[[id:127cefde-76f3-437b-ba9c-72ed8e928498][常量表达式]] [fn:2]
  2. *new 可能失败* ，抛出 =bad_alloc= 异常，可以用 =std::nothrow= 告诉 new *无法分配内存就返回空指针* [fn:3]
#+begin_src cpp
// 分配内存再初始化
int* ptr(new int);
*ptr = 7;

// 分配内存后立刻初始化
int* ptr1{ new int (5) };     // 直接初始化
int* ptr2{ new int { 6 } };   // 列表初始化

// 删除指针指向的内容，并将指针置为空
delete ptr;
ptr = nullptr;
#+end_src


**** 定位new
:PROPERTIES:
:ID:       a28bd13a-7ea4-4200-828a-67c0e5f3eb4b
:END:
- 定位new :: （placement new）在已分配的内存上调用[[id:50402d44-720e-42ed-b590-2b18d219acc1][构造函数]]，常用于内存池
#+begin_src cpp
void* memory = /* 预分配的内存 */;
T* obj = new(memory) T(args...);  // 在 memory 上构造 T 类型的对象
#+end_src


*** delete
:PROPERTIES:
:ID:       77576e9a-1dfa-43fa-924e-21a8dbcb9336
:END:
- delete :: C++运算符，调用[[id:b6a06a10-6ae8-4e39-ab66-beea8919d57d][堆]]上对象的[[id:be44b0c2-d234-409f-b1a6-b447e365db37][析构函数]]，再释放该对象占用的堆内存
  1. =delete[]= 用于 *释放动态数组* ，调用动态数组中每个元素的析构函数，再释放整个数组占用的堆内存
  2. delete[] *如何知道要释放的内存大小* ？ new[] 会记录分配的内存大小（程序员无法访问），delete[] 就知道释放多少内存；


*** malloc
:PROPERTIES:
:ID:       84479c76-4d35-43fc-93ad-5cd3bbc78701
:END:
- malloc :: C标准库函数，堆上手动指定大小分配内存，返回指向该内存的[[id:6acf0727-89af-4954-a8fb-1fc5b215c93e][空指针]]
  1. 用户申请内存 =<128KB= ，通过 =brk()系统调用=  在 堆区       申请内存
  2. 用户申请内存 =>128KB= ，通过 =mmap()系统调用= 在 内存映射区 申请内存


*** free
:PROPERTIES:
:ID:       e3fa3d7f-99c7-47d0-9e4a-a8718552a2ab
:END:
- free :: C标准库函数，释放 malloc 分配的堆内存


* Footnotes

[fn:1]
#+begin_src cpp :results output :namespaces std :includes <iostream> <cstdlib> <cstdint>
// 全局变量（数据段）
int g_a = 10;
int g_b = 10;

// 全局常量（代码段-常量区）
const int c_g_a = 10;
const int c_g_b = 10;

// 全局静态变量（数据段）
static int s_g_a = 11;
static int s_g_b = 11;

int main() {
  // 局部变量（栈）
  int a = 10;
  int b = 10;

  // 静态局部变量（数据段）
  static int s_l_a = 10;
  static int s_l_b = 10;

  // 局部常量（栈）
  const int c_l_a = 10;
  const int c_l_b = 10;

  // 堆区内存（堆）
  int* p_l_a = new int(100);
  int* p_l_b = new int(100);

  // 地址打印
  cout << "局部变量a         ：" << reinterpret_cast<uintptr_t>(&a) << endl;
  cout << "局部变量b         ：" << reinterpret_cast<uintptr_t>(&b) << endl;

  cout << "const局部变量c_l_a：" << reinterpret_cast<uintptr_t>(&c_l_a) << endl;
  cout << "const局部变量c_l_b：" << reinterpret_cast<uintptr_t>(&c_l_b) << endl;
  cout << '\n';

  cout << "全局变量g_a        ：" << reinterpret_cast<uintptr_t>(&g_a) << endl;
  cout << "全局变量g_b        ：" << reinterpret_cast<uintptr_t>(&g_b) << endl;

  cout << "static全局变量s_g_a：" << reinterpret_cast<uintptr_t>(&s_g_a) << endl;
  cout << "static全局变量s_g_b：" << reinterpret_cast<uintptr_t>(&s_g_b) << endl;
  cout << "static局部变量s_l_a：" << reinterpret_cast<uintptr_t>(&s_l_a) << endl;
  cout << "static局部变量s_l_b：" << reinterpret_cast<uintptr_t>(&s_l_b) << endl;
  cout << '\n';

  cout << "const全局变量c_g_a ：" << reinterpret_cast<uintptr_t>(&c_g_a) << endl;
  cout << "const全局变量c_g_b ：" << reinterpret_cast<uintptr_t>(&c_g_b) << endl;
}
#+end_src

#+RESULTS:
#+begin_example
局部变量a         ：140730249679336
局部变量b         ：140730249679340
const局部变量c_l_a：140730249679344
const局部变量c_l_b：140730249679348

全局变量g_a        ：94857618763848
全局变量g_b        ：94857618763852
static全局变量s_g_a：94857618763856
static全局变量s_g_b：94857618763860
static局部变量s_l_a：94857618763864
static局部变量s_l_b：94857618763868

const全局变量c_g_a ：94857618755588
const全局变量c_g_b ：94857618755592
#+end_example


[fn:2]
#+begin_src cpp :results output :namespaces std :includes <iostream> <cstddef>
std::size_t length{};
std::cin >> length;
int* array{ new int[length]{} }; // NOTE 动态分配的数组，长度不需要为常量表达式
array[0] = 5;
delete[] array;                  // 删除动态数组

int* array{ new int[5]{ 9, 7, 5, 3, 1 } };  // 列表初始化
auto* array{ new int[5]{ 9, 7, 5, 3, 1 } }; // 使用 auto 避免写两次 类型
#+end_src

[fn:3]
#+begin_src cpp
int* value { new (std::nothrow) int{} }; // 分配内存失败返回空指针
if (!value) {                            // 判断是否分配成功
    std::cerr << "Could not allocate memory\n";
}
#+end_src
