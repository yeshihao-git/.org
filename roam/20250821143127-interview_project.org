:PROPERTIES:
:ID:       84b76ad2-597e-40d3-9332-27c9700ece88
:END:
#+title: 项目
#+filetags: interview

* 全栈聊天项目
** 登录 :业务:
首先用户在登录聊天框中输入账号密码，点击登录，就由 QT 的 HTTP 管理模块，将消息打包成 JSON 格式发送到后端的网关服务器。后端的网关服务器里注册了一些回调函数，然后网关服务器收到这个 JSON 之后就去调用对应的登录回调函数。在登录回调函数里会先去找状态服务器，然后状态服务器就去查询用户ID对应的聊天服务器，然后返回聊天服务器的 IP、端口以及一个用于临时身份验证的 token。客户端收到后，使用 它的TCP管理模块去连接聊天服务器，并用 token 进行临时身份验证。验证成功时聊天服务器去 MySQL 里查询用户的基本信息、好友申请列表以及好友列表，并返回给 客户端。客户端用返回的数据更新它的user管理模块（user管理模块里存的就是用户相关的一些信息），最后用user管理模块里面的信息更新界面。
** 验证码 :业务:
首先用户在注册界面输入邮箱，点击获取验证码，客户端检查邮箱格式，若正确，就通过 HTTP 管理模块，将用户输入打包成 JSON 格式发送到后端的网关服务器。网关服务器调用验证码回调函数找到验证服务器，验证服务器通过 UUID 生成一个随机的四位数，并记录到 Redis 中设置过期时间，然后将这个四位数发送到用户邮箱。
** 注册 :业务:
首先用户在注册界面输入用户名、密码、重复密码、邮箱、验证码，客户端进行简单的检验（字段是否为空，邮箱格式是否正确），然后通过 HTTP 管理模块将这些数据打包成 JSON 格式发送到后端的网关服务器，网关服务器调用注册回调函数，检查验证码，若和 Redis 当中的验证码一致，则将这条记录插入到 MySQL，并返回给客户端注册成功的信息。
** 重置密码 :业务:
首先用户在重置密码界面输入邮箱，点击获取验证码，得到并输入校验码以及新密码后，点击重置密码，这些数据就会被打包成一个 JSON， 通过 HTTP 管理模块发送到后端的网关服务器。网关服务器调用重置密码回调函数：检查一下验证码是否正确，以及这个邮箱是否存在，没问题之后就更新密码，并且返回密码重置成功给客户端。
** 好友搜索 :业务:
首先用户在好友搜索框里输入好友名称，这些数据被打包成一个 JSON，通过 TCP 管理模块发送到聊天服务器，聊天服务器调用好友搜索回调函数。先查 Redis， Redis 没有就查 MySQL， MySQL 查到后，回写 Redis，并返回给客户端。客户端收到后，弹出查找成功的窗口。
** 添加好友流程 :业务:
申请好友方A，在搜索框输入 被申请方B的名字，点击搜索，搜索成功后点击添加好友按钮，弹出添加好友会话框，填入备注之类的信息，点确定，相关信息被打包成一个 JSON， 通过 TCP 管理模块发送到聊天服务器，聊天服务器调用对应的回调函数：更新数据库的好友申请表（记录为申请方id，被申请方id，状态），记录中状态为 0 代表还没有添加好友；接着通知 B，首先在 Redis 里查 B 和他所在服务器的映射关系，如果不存在，说明 B 不在线，直接返回。如果存在，就能通过 B 的 uid 找到他所在的服务器。如果和我们是同一个服务器，就直接通过 B 的 uid 找到他所在的会话，然后回包给他的客户端。如果不在同一个服务器，那就通过 gRPC 将消息转发给 B 所在的聊天服务器，再找到 B 所在的会话，回包给客户端。此时 B 的好友申请列表显示好友申请请求。B 点击添加，在好友验证对话框里填写备注相关的信息，点击确定，相关信息就会打包成一个 JSON 通过 TCP 模块发送到聊天服务器，聊天服务器调用对应的回调函数：更新数据库的好友申请表、好友表，接着通知 A ，先定位 A 的位置，Redis 里看有没有 A 的 uid 和他所在的聊天服务器的映射，若没有，代表A不在线，直接返回。若有，判断A是在同一个聊天服务器，还是在不同聊天服务器。如果在同一个聊天服务器，就直接通过A的 uid 找到他所绑定的会话，然后发送消息给A的客户端。如果不在同一个服务器就通过 gRPC 将消息转发到A所在的聊天服务器，再通过 A 的 uid 找到对应的会话，将消息返回给他所在的客户端，A客户端里的这个 user管理模块 就会被更新，界面中更新 A 的好友列表。
** MVC架构 :客户端:
M：模型层，用于存储数据和提供数据访问。对应代码中的 user管理类
V：视图层，用户可以看到的UI界面。对应代码中的 界面类
C：控制层，业务逻辑控制。对应代码中的 http/tcp管理类
具体流程：视图层（界面类）用户进行某些操作，控制层（http/tcp管理类）与后端交互获取数据更新 模型层（user管理类），视图层 再根据 模型层 更新界面
** 动态加载聊天列表 :客户端:
在列表滚动区域捕获鼠标滚轮事件，滚动到底部时发送一个加载聊天用户的信号，此时UI界面加载gif动画，后台加载好友列表，加载完毕后更新UI界面
#+begin_example cpp
bool ChatUserList::eventFilter(QObject *watched, QEvent *event)
void ChatDialog::slot_loading_chat_user() // 加载gif动画（LoadingDlg，模态形式），后台ChatDialog::addChatUserList() -> UserMgr::GetChatListPerPage() -> 更新UI界面
#+end_example

** redis在项目中的使用场景/用到的redis函数？ :redis:
String的Set/Get：临时数据（登录token、验证码）、热点数据（用户信息）、共享数据（用户服务器映射）
Hash的HSet     ：负载均衡（连接数最小的聊天服务器）
# RedisMgr::GetInstance()->HSet(LOGIN_COUNT, server_name, "0"); 3个参数分别为：哈希表的键、字段名、字段值

1. 用户登录token（登录）               #define USERTOKENPREFIX  "utoken_"
2. 验证码（注册、重置密码）            let code_prefix = "code_";
3. 连接数最小的聊天服务器（负载均衡）  #define LOGIN_COUNT  "logincount"
4. 用户所在服务器（查用户在哪个服务器）#define USERIPPREFIX  "uip_"
5. 用户信息（用户名）                  #define NAME_INFO  "nameinfo_"
           （id）                      #define USER_BASE_INFO "ubaseinfo_"

** mysql存储哪些数据？ :mysql:
- user表         :: 用户信息表
#+begin_comment
uid: 用户唯一标识符
name: 用户名
email: 邮箱地址
pwd: 密码
nick: 昵称
desc: 个人描述
sex: 性别
icon: 头像路径
#+end_comment

- friend表       :: 好友关系表（两个用户成为好友时，数据库中插入两条记录）
#+begin_comment
self_id  : 用户自己的ID
friend_id: 好友的ID
back     : 备注名称
#+end_comment

- friend_apply表 :: 好友申请表
#+begin_comment
from_uid: 申请人ID
to_uid  : 被申请人ID
status  : 申请状态（0=待处理，1=已同意）
#+end_comment

** mysql表中哪些字段设置为索引，为什么？ :mysql:
- user表 ::
  uid  ：唯一索引 -> uid搜索用户查询mysql
  email：唯一索引 -> 用户名搜索用户查询mysql
  name ：普通索引 -> 邮箱登录，登录验证查询mysql
- friend表 ::
  self_friend(self_id, friend_id)：联合唯一索引，防止重复添加好友
- friend_apply表 ::
  from_to_uid(from_uid, to_uid)： 联合唯一索引，防止重复申请好友
** 项目中微服务的拆分、职责边界怎么划分？ :服务端:
*网关服务器* ：外部请求的统一入口，根据客户端请求业务不同，协调其他服务共同完成。可以进行 登录、注册、重置密码 等业务
*状态服务器* ：用于查询聊天服务器相关的信息：
             1. 聊天服务器ip、端口、token
             2. 聊天服务器与用户映射
             3. 聊天服务器连接数
*验证服务器* ：用于发送验证码到用户邮箱
*聊天服务器* ：用户客户端登录后所在的服务器。可以进行 好友添加、发送消息 等业务

** 怎么处理粘包/怎么设计的buffer？ :服务端:
tlv消息格式： =消息 = 4字节消息头（消息id+消息长度） + 消息体=
1. 用一个 C风格数组（char数组）接收异步读取到的数据
2. 先固定读取4字节，提取出里面的 消息id、消息长度 并记录到 recv_node结构体；再根据消息长度读取消息体，记录到 recv_node结构体
3. 将recv_node结构体、CSession放到 logic_node结构体（包含CSession意味着后续可以在此CSession中发送消息）交给LogicSystem处理

** tmp
*** 服务端
内存中的状态管理类
1. ApplyInfo：好友申请信息（包含申请人信息和申请状态），用于好友申请列表展示
2. UserInfo ：记录用户完整信息
3. UserMgr  ：用户会话管理，维护用户ID到会话的映射关系
   # 没有存储好友列表的类，只有在用户登录时，从mysql中查寻好友存储在 std::vector<std::shared_ptr<UserInfo>>，返回给客户端

**** 登录和聊天分别用什么协议？两个客户端之间如何实现聊天功能？
- 登录使用 HTTP，聊天使用 TCP 并在应用层进行了拆包处理，聊天服务器之间消息转发使用 gPRC，
- 客户端在聊天服务器的会话中发送消息，消息被交到逻辑系统的消息队列里，逻辑系统后台起了一个线程专门处理消息队列里的内容，根据消息id找到文本聊天回调函数，在这个函数中先查询redis，找到我们要发送消息的目标的聊天服务器ip地址，若两个客户端在同一个聊天服务器，就直接通过内存里的UserMgr找到对应的会话发送消息，若两个客户端在不同聊天服务器，就通过grpc发送到另一个聊天服务器

**** 登录用的http的哪个方法，为什么用post，不用get？
- POST；POST的语义是提交数据，且数据可以是JSON格式的数据且在请求体中，相比与get语义上的使用更准确，传输更安全

**** 为什么用异步不用同步？
- IO用同步会阻塞，而异步使用事件驱动机制，无需等待IO就能去做其他的事，比如处理其他连接，这样就能做到一个线程处理大量的并发连接，而同步只能一个连接处理完再处理下一个

**** 什么是asio，具体可以实现哪些功能？为什么要选择项目中的这个网络库（asio），以及这些技术？
- C++中异步IO库，通过异步操作进行高效的网络通信，比如 连接建立，消息收发
- 聊天系统需要同时处理大量的用户连接，用户多消息收发也多，使用同步效率太低，因此考虑异步，而C++中有名的异步IO库就是[[id:c590482b-2e5a-4617-822b-74a9dd015ae5][asio]]

**** asio的原理是什么？ [[id:c590482b-2e5a-4617-822b-74a9dd015ae5][asio]]
- asio中主要是异步操作，每次调用异步操作时注册一个完成处理函数，后续调用io_context::run()时，内部会运行一个事件循环，处理内部的任务队列中的任务（调用异步操作时注册的完成处理函数），直到任务队列为空或io_context停止

**** redis连接池、mysql连接池、io线程池（AsioIOServicePool）、grpc连接池 怎么设计的？
- redis连接池：
  创建连接：host、port、pwd
  存放连接：queue（存放redis连接，实现顺序存取）、poolSize
  实现同步：mutex、condition_variable
  检查线程：check_thread（每60秒检查一次所有连接）、counter
  池子关闭：b_stop
  「方法」：创建连接池、关闭连接池、取出连接、归还连接、检查连接（判断连接是否有效，无效则重建）

- mysql连接池：
  创建连接：主机名和端口（url）、用户名（user）、密码（pass）、数据库名（schema）
  存放连接：queue、poolSize
  实现同步：mutex、condition_variable
  检查线程：check_thread（每60秒检查一次，检查空闲时间超过5秒的，用select 1查询数据库检测，查询数据库成本比较高，因此只检查时间超过5秒的连接）
  池子关闭：b_stop
  「方法」：创建连接池、关闭连接池、取出连接、归还连接、检查连接

- io连接池（AsioIOServicePool）：
  每一线程对应一个io_context，因此不使用queue存放io_context而是vector，通过vector索引就能访问对应io_context，无需锁
  三个vector，分别放 io_context、work、thread
  work 防止 io_context 提前退出
  「方法」：创建池子、关闭池子、获取连接

- grpc连接池：RPConPool（与验证服务器通信）、StatusConPool（与状态服务器通信）、ChatConPool（与聊天服务器通信）
  创建连接：host、port
  存放连接：queue、poolSize
  实现同步：mutex、condition_variable
  池子关闭：b_stop
  「方法」：创建池子、关闭池子、取出连接、归还连接

**** 为什么需要网关服务，没有行不行？
- 没有网关服务，则客户端复杂性增加，客户端就需要与多个后端服务通信
  #+begin_comment
  有网关的情况：
  Web客户端 → GateServer → StatusServer/ChatServer
  无网关的情况：
  Web客户端 → StatusServer
  Web客户端 → ChatServer
  Web客户端 → 其他服务...
  #+end_comment

**** 为什么要把登录和聊天拆分成不同的服务器？
- 解耦登录和聊天功能：
  1. 登录使用HTTP协议，聊天使用基于TCP的自定义协议，耦合在一起协议处理的复杂性就高了
  2. 用户量上来了，聊天服务器就需要扩展了，耦合在一起物理机器的性能可能不够用
  3. 某个聊天服务器故障，不会影响用户登录，可以将用户分配到另一个正常的聊天服务器

**** 每个聊天服务器都是一个单独的ip，如果一个服务器挂了、那么这个服务器上的客户端都会受到影响，那如何做到无损切换服务器？
- [[id:2e8203cb-5616-41c8-b2c4-a46b57eaa9b9][图:一致性哈希扩容和缩容]]

**** [[id:a5c426e4-365b-447d-89f3-eddc9c517a01][grpc]]用的什么协议？用的同步api还是异步api？protobuf的作用？
- [[id:0b3fad26-6096-455d-a8af-79522c5113f3][HTTP/2]]、[[id:13f67abf-4087-4d20-87d7-ed11e5b99edc][Protocol Buffers]]
- 同步
- 用于序列化结构化的数据，体积更小、解析速度更快

**** grpc如何实现断线重连
- 客户端Stub会持续监控底层连接，若连接断开，会尝试自动重连。重连采用 指数退避算法

**** grpc在项目中解决的什么问题？
- grpc用于服务之间的通信；主要用来解决
  1. 统一的通信方法（grpc）
  2. 跨聊天服务器通信（两个聊天服务器之间通信）
  3. 负载均衡和聊天服务发现（网关服务器通过状态服务器发现连接数最小的聊天服务器）

**** TODO 怎么封装的http和tcp？
- 封装HTTP：HttpConnection类
  *成员* -> 填充HTTP请求响应报文使用beast的 beast::http::request 、beast::http::response ；网络传输使用boost::ip::tcp::socket；存储从socket异步读到（beast::http::async_read） 的原始字节 beast::flat_buffer；60秒超时的定时器；存储get参数的unordered_map；解析后的url
  *函数* -> 读取请求的函数、解析报文的函数（判断GET/POST，交给LogicSystem处理）、发送响应的函数、超时函数

- 封装TCP：CSession
  *成员* -> 会话id（标识会话），用户id（标识会话所属用户）；会话关闭标识（标识会话是否已关闭）；网络传输socket；数据缓冲区（char data[]）；发送消息队列（实现消息的有序发送）；发送队列的互斥锁；_recv_msg_node（消息体节点），_recv_head_node（消息头节点），b_head_parse（标识当前是否正在解析消息头）
  *函数* -> 绑定/查询用户和会话的函数、



**** [ ] 聊天服务器如何实现的负载均衡、当有大量请求到来时，如何实现连接的均匀分布？
**** [ ] 聊天过程中的数据如何产生，如何传递，如何存储
**** [ ] 如果离线消息过大，需要等所有数据发送完后再删除吗，如果发送过程中服务断掉，那下一次要重复发送吗
**** [ ] 大量用户连接时，负载的处理和断连的处理
**** [ ] 客户端请求到达服务端的通信链路
**** [ ] 数据库中用户密码的加密存储
**** [ ] 高并发场景下单个连接数不足的问题具体讲讲
**** [ ] 讲项目做的好的一个点？项目还有什么不足和改进点？
**** [ ] 多线程并发修改全局变量会有什么问题，如何解决? （除了加锁还有什么方法?)
**** [ ] 如何存储大量的聊天信息，包括音频视频以及各种大文件
**** TODO 如何获得服务器性能的？（测试）
**** [ ] 如何解决大量tcp连接的性能问题？如何用户登陆后长时间没有请求（心跳机制），如何又突然要发消息了，需要重新登录吗？
**** [ ] redis如果遇到内存快满了，如何处理

**** [ ] 客户端使用什么接口进行消息发送的？

**** TODO 连接池怎么设计连接数？当有大量请求时，如何处理连接超时问题？
- redis、grpc连接池大小为5，mysql根据配置文件动态变化

*** 客户端
**** 滚动聊天布局
*布局* 从外到内：ChatView -> MainLayout -> ScrollArea -> w（widget，QScrollArea中需要QWidget作为内部可滚动内容） -> pHLayout_2（为了让滚动条覆盖在内容之上） -> pVLayout_1 -> new QWidget()
*滚动加载* 滚动条最大值改变时会发出rangeChanged信号，意味着添加了新的聊天内容导致聊天布局中的内容超出显示，调用槽函数 将滚动条设置为最大值（滚动到最底部），同时一段时间内可能多次添加聊天内容因此加入防抖动处理，每隔500毫秒将标志位isAppended=false
#+begin_example cpp
connect(pVScrollBar, &QScrollBar::rangeChanged,this, &ChatView::onVScrollBarMoved); // 滚动条对象的信号 QScrollBar::rangeChanged -> 滚动条的最小值/最大值改变时发出这个信号

// 添加新内容后自动将滚动条滚动到最底部
void ChatView::onVScrollBarMoved(int min, int max)
{
    if(isAppended) // isAppendedo标志位，添加item可能调用多次
    {
        QScrollBar *pVScrollBar = m_pScrollArea->verticalScrollBar(); // 获取滚动区域的垂直滚动条 pVScrollBar
        pVScrollBar->setSliderPosition(pVScrollBar->maximum()); // 将滚动条设置为最大值（即滚动到最底部）
        QTimer::singleShot(500, [this]() //防抖动处理：设置500毫秒延迟，因为添加item可能调用多次
        {
            isAppended = false;
        });
    }
}
#+end_example

**** TODO 气泡聊天对话框
设计一个基类ChatItemBase，网格布局，见：[[id:5d43812f-d369-4b8c-9781-5486788d6e70][图:气泡聊天对话框网格布局]]
其中 Bubble 为具体聊天气泡，对应基类 BubbleFrame，负责设置边距、设置具体消息气泡的widget、气泡绘画事件（方框和三角）；消息类型分为 文本、图片
因此以 BubbleFrame 为基类派生 TextBubble、PictureBubble

***** 图:气泡聊天对话框网格布局 :ATTACH:
:PROPERTIES:
:ID:       5d43812f-d369-4b8c-9781-5486788d6e70
:END:
[[attachment:_20250923_191619screenshot.png]]
网格布局，NameLabel为用户名、IconLabel为用户头像、Bubble为聊天信息、Spacer为弹簧  用于将 聊天信息 挤压到右侧


* 开放原子大赛:开源开发者工具及应用挑战赛
** 流程
用户通过 Alt+x 打开输入框进行输入，输入字符大于3时执行搜索
先将输入内容根据两个关键字符拆分为多个部分：第一个字符，代表当前ripgrep使用的模式（普通、正则）；最后出现的@字符，@字符左侧到第一个字符之间为用户搜索内容，@字符右侧为搜索路径（可选）
再通过 QProcess 运行rg命令两次，分别获取 匹配行、内容匹配部分（用于后续高亮）等输出，用正则表达式 截取输出中的文件名、行号、匹配行、内容匹配部分 填充 文件项结构体列表（QList<KeyFinderFileItem> ），再用 文件项结构体列表 填充 自定义单文件结果列表模型（KeyFinderSingleFileListModel）
从 自定义单文件结果列表模型 中取出每一项（文件项结构体）创建 文件项widget，文件项widget 用 文件项结构体 填充 QGroupBox标题、创建和填充 行widget（KeyFinderLinesWidget） 并加到 QGroupBox内的垂直布局，再将 文件项widget 追加到 文件项widget列表，并在 列表视图 对应索引处设置widget，模型 中设置widget尺寸以此更新 列表视图（模型中调用 setData() 设置widget尺寸，然后发出 dataChanged信号 更新视图）
自定义的输入框（KeyFinderEdit）重写了 按键按下事件，键盘上下会在搜索结果中的上下选择项，键盘回车跳转到对应位置
上下选择的实现：上选择 检查当前选中的文件项（currRow），如果到了第一行（isSelectedFirst()）就取消当前选择，移动到上一个文件项（若是第一个则跳到最后一个文件项），否则当前文件项目中选择上一个。下选择类似

** 主界面
垂直布局 + 「显示」自定义的输入框（KeyFinderEdit）+ 列表视图（QListView）关联 自定义单文件结果列表模型（KeyFinderSingleFileListModel）、取出 选择模型

*** 列表视图（QListView）
*用下述的widget填充*

**** 文件项widget（KeyFinderFileItemWidget）
存储 行widget（KeyFinderLinesWidget）+ QGroupBox + 垂直布局（QVBoxLayout）
具体样式：垂直布局 内放很多 QGroupBox，QGroupBox 内设置 垂直布局

***** 行widget（KeyFinderLinesWidget）
创建 水平布局，取出 行项结构体（KeyFinderLineItem）中的 行号、行内容、匹配内容；将行号渲染为绿色，行内容 根据 匹配内容 拆分为三个部分，将匹配内容渲染为红色后 重新拼接成 行内容

*** 自定义单文件结果列表 模型（KeyFinderSingleFileListModel）
存储 文件项结构体列表（QList<KeyFinderFileItem> ）
实现 标准读写接口（data()、setDate()）、标准行数量接口（rowCount()）
*用下述的结构体填充*

**** 文件项结构体 列表（QList<KeyFinderFileItem> ）
存储 文件路径 + 错误 + 行项结构体列表（QList<KeyFinderLineItem>）

***** 行项结构体 列表（QList<KeyFinderLineItem>）
存储 行号 + 行内容 + 匹配内容


* 基于C++11重构百万并发Reactor服务器
** 项目介绍
这个一个基于 reactor模型实现的高并发TCP服务器框架，基于这个TCP服务器框架可以根据业务逻辑进行扩展（eg：TCP服务器框架基础上封装EchoServer），具有 事件驱动、可扩展性高、线程安全 等特点。
** 整体架构
这个TCP服务器框架 采用主从reactor模式：主事件循环绑定Accept，负责监听并且接受新连接，分配从事件循环创建Connection，负责IO。它的底层是通过 epoll_wait 不断返回事件，根据事件类型调用不同回调函数（上层向下层注册回调函数，下层根据触发的事件类型调用不同回调函数）[fn:1]。
在这个TCP服务器框架上可以根据业务逻辑封装服务器（eg：EchoServer），添加可选的线程池用于处理具体业务。
** 线程模型
TCP层，one thread one loop（一个线程对应一个事件循环）：（主线程）主事件循环绑定Accept，负责监听、接受新连接；（其他线程）从事件循环线程池中的从事件循环绑定 Connection，负责IO。
应用层，（其他线程）有可选的工作线程池负责业务处理（计算密集型任务）。
** 负载均衡（Connection如何与EventLoop对应）
对客户端socket的fd进行哈希运算（对线程数量取余）得到的数作为从事件循环的下标索引，以此事件循环创建Connection
#+begin_example cpp
/* 客户端socket的fd通过哈希计算得出的值作为要取的从事件循环的下标 */
spConnection conn(new Connection(subloops_[clientsock->fd()%threadnum_].get(),std::move(clientsock)));
#+end_example

** tmp
** YES 从 accept 新连接到连接读写、消息处理、再到回包的完整链路描述，包括涉及的对象和回调绑定位置
- 新连接： *「主线程」* Acceptor::newconnection()接受连接，构造客户端socket，回调TcpServer::newconnection()，在从EventLoop中选择一个，并创建Connection，Connection内部有客户端socket和clientchannel并注册读写/错误/关闭回调，后续Channel::handleevent()触发对应回调
- 消息处理/回包： *「IO线程A」* clientchannel触发读事件，回调Connection::onmessage()，Connection::onmessage()读取数据到自己的缓冲区，回调TcpServer::onmessage()，TcpServer::onmessage()回调上层EchoServer::HandleMessage()，EchoServer::HandleMessage()中将 =任务std::bind(&EchoServer::OnMessage,this,conn,message)= 放入工作线程池的任务队列， *「WORK线程A」* 调用任务EchoServer::OnMessage，EchoServer::OnMessage调用Connection::send()发送响应，Connection::send()中判断出当前执行该函数的线程是「WORK线程A」，于是通过EventLoop::queueinloop将任务放入conn对应的EventLoop::taskqueue中，EventLoop::queueinloop内通过eventfd唤醒「IO线程A」， *「IO线程A」* 处理taskqueue

** YES 为什么要用 eventfd 唤醒而不使用其他手段？
- 简单只需1个fd，与epoll无缝集成
  pipe                  ：需要2个fd
  pthread条件变量/信号量：不能纳入epoll的等待集合
  signal                ：全局性强
  timerfd               ：专门做计时器事件，不适合作为跨线程“任务到达”的通知
  C++11互斥锁/条件变量  ：与epoll集成不好，会造成双重等待（既等条件变量，又等epoll_wait）

** YES Connection在回调过程中为什么要用shared_from_this()，用this行吗，或者 new 一个Connection的共享指针？
# Connection::onmessagecallback_(shared_from_this(),message);
- 用 this 不行，因为 this 不能增加 Connection 的引用计数，可能在回调过程中 Connection 被意外释放；new一个Connection的共享指针也不行，因为这样创建的共享指针引用计数与正在管理Connection的共享指针引用计数不同步（创建了新的shared_ptr），使用shared_from_this() 就能共享正在管理Connection的共享指针的引用计数

** YES 如何做消息拆包？Buffer::pickmessage() 三种分隔方式各自适用什么场景？
- 消息 = 消息头(固定4字节) + 消息体；读取消息头获取长度信息，根据长度信息读取消息体
- 0：无分割符，适合定长/持续流（eg：音视频）
  1：4字节消息头（默认），处理粘包问题
  2：\r\n\r\n分隔，处理HTTP

** EventLoop::stop_ 是原子变量，停止时如何保证不会丢任务？如何优雅退出所有 subloops_ 与工作线程？
- EventLoop::stop() 会将 stop_ 设置为 true，然后通过 eventfd 通知 EventLoop 将任务队列中的任务全部处理，同时 stop_=true 后，EventLoop::run() 中 while循环停止，也就是 事件循环停止了
- 设计了一个 ThreadPool::stop()，将 原子变量 stop_设置为true，然后唤醒全部阻塞的线程，等待它们执行完成；被唤醒的线程发现 stop_=true且任务队列为空就直接return，否则先将任务做完，下次while循环退出
  *补充* ：不直接在析构函数中设计这个逻辑是为了增加灵活性，用户可以直接调用 stop() 来手动停止线程池；ThreadPool::stop() 中一开始设计 if(stop_) return; 是因为join过的线程不能再join
  #+begin_example cpp
  void ThreadPool::stop()
  {
      if (stop_) return;       // 被join过的线程不能再join的，否则会调用terminate；eg：第一次stop()，对所有线程join了；第二次 stop 若没有这行，则再次join，则程序终止
      stop_ = true;
      condition_.notify_all();  // 唤醒全部的线程。
      // 等待全部线程执行完任务后退出。
      for (std::thread &th : threads_)
          th.join();
  }
  #+end_example

** YES 为什么 EventLoop 里集成了 timerfd_？EventLoop::conns_ 和 TcpServer::conns_ 都维护了连接，为什么要两份？
- timerfd是计时器，可以打破程序执行的流程，每隔一段事件去做某件事，这里通过 timerfd 来定期检查 Connection 是否超时，将超时Connection从EventLoop中删除，并从TcpServer中删除
  #+begin_comment
  *具体来说* ：EventLoop中继承 timerfd、timerchannel 周期性触发 handletimer()，handletimer()设置重新计时并遍历所有 Connection，若超时，则从EventLoop::conns中删除，回调TcpServer::removeconn，TcpServer::removeconn将Connection从TcpServer::conns中删除
  #+end_comment

- TcpServer::conns 管理全局的Connection（eg：统一关闭），EventLoop::conns管理局部Connection（eg：空闲连接检测）
  #+begin_comment
  假设将空闲连接检测交给TcpServer::conns，则TcpServer性能不好，因为需要定期完整检查全部Connection，而TcpServer的职责主要是监听和接受新连接
  #+end_comment

** YES 有无考虑进程级信号处理（如 SIGINT）触发所有 loops、ThreadPool 的优雅退出？
- 有进程级的信号处理，捕获到 SIGINT、SIGTERM 时，调用自定义的Stop函数
  #+begin_example cpp
  signal(SIGTERM,Stop);    // 信号15，系统kill或killall命令默认发送的信号。
  signal(SIGINT,Stop);     // 信号2，按Ctrl+C发送的信号。

  // Stop函数中
  echoserver->Stop();
  delete echoserver;
  #+end_example

** YES 实现主从 Reactor 吗？mainloop_ 和 subloops_ 的职责边界是什么？新连接如何在多个 EventLoop 之间分配（策略/理由），支持连接迁移吗？
- 主事件循环负责 监听/接受 新连接（Acceptor绑定在主事件循环），从事件循环负责Connection的IO事件、超时管理（事件循环内有个定时器，每隔一段时间检查Connection）
- 使用 哈希方法，简单且无锁（eg：轮询按顺序分配连接，因此可能需要锁）

** YES 为什么 Socket、Channel 在不同地方用 unique_ptr，而连接放在 std::map<int, spConnection>？
- socket表示网络连接，channel表示事件，每个 Connection 独占各自的socket、channel，因此使用 unique_ptr；而 Connection 存在于 TcpServer 和 EventLoop 中，且在一些回调函数中需要传递 Connection，因此使用 shared_ptr，以便在回调链路中延续生命周期

** YES ThreadPool 主要用于 IO 线程还是工作线程？threadtype_ 的意图是什么？
- 都有，用 threadtype_ 标识线程池类型

** YES 用什么方式压测（客户端、QPS、RT、连接数、CPU/内存）？
- 虚拟机：4核CPU、2g内存 Ubuntu系统
  sh脚本中在后台起了30个客户端，每个客户端发送10万个请求，计算下来大概1秒10万
- autodl重庆A区：32核CPU 120g内存 Ubuntu系统
  sh脚本中在后台起了30个客户端，每个客户端发送100万个请求，关闭可选的工作线程池，IO线程数改为30（也就是整个程序31个线程），计算下来QPS=100万
  + top命令看CPU和内存
  + QPS=请求/每秒，QPS是每秒查询率



* 虚拟数字人
** 项目流程
基于博物馆场景的数据集对大模型进行微调，增强模型对于博物馆场景的理解能力，但模型对于具体数字类数据的推理依旧不够准确；因此考虑外挂知识库，具体做法是将知识库进行向量化存入向量库，用户查询时，用户查询会被向量化并在向量库中进行相似度搜索，相似度top k的内容会作为模型的参考，我们可以设置prompt要求模型直接使用检索出的数字，以达到数字类数据的推理准确性。

** （低优先级）具体细节
*微调流程* ：[[https://xtx0o8yn7x.feishu.cn/docx/XjvpdaeQcoF8d3xhpbCcoOJNn9b][微调]]
1. 加载分词器​​（AutoTokenizer）预处理数据，使用分词器将文本编码为数字，得到数据集
2. 加载模型​​（AutoModelForCausalLM + BitsAndBytesConfig量化）：量化，减少显存占用
3. 配置训练参数​​（TrainingArguments）：训练的超参数（学习率、批次等）
4. 配置Lora参数（peft中的LoraConfig）：用于高效参数微调
5. SFTTrainer（训练参数 + Lora参数 + 数据集）开始训练

#+begin_comment
使用 hugging face 中的库：
1. transformers：基础模型库
   用的 AutoTokenizer：加载分词器，用于将文本编码为数字
   AutoModelForCausalLM：加载模型
   BitsAndBytesConfig：量化参数（减少显存占用 4位量化、8位量化）
   TrainingArguments：训练超参数（学习率、批次大小等）
2. peft：参数高效微调库，用的 LoRA
3. trl：强化学习微调库，用的 SFTTrainer（监督式微调的训练器）
#+end_comment

- [X] 项目用的是哪种微调方式，LoRA、Freeze（冻结预训练层）还是全量微调？为什么在虚拟数字人场景下选择这种方案？
  + 用的LoRA（低秩适配），将原始大权重矩阵拆为两个低秩矩阵A、B，训练时只训练A、B，推理时合并原始矩阵和A、B；训练量更少
  + 在终端设备（eg：智能屏）的环境下算力不强，对精确度要求不需要那么高，选择 LoRA 模型响应更快
- [X] 虚拟数字人需要适配特定场景（比如客服、教育）的交互风格，你们的微调数据集是怎么构建的？
  + 从博物馆官网上爬来，然后交给chatgpt生成角色对话，且保持角色语气一致性

*外挂知识库流程* ：[[https://xtx0o8yn7x.feishu.cn/docx/UOAadjjReoI6UBxPq4lcI9frnMb][外挂知识库]]
# 以下都是 langchain 的模块
1. 用 UnstructuredFileLoader 加载文件，将非结构化文件（eg：PDF、Word、TXT等）转换为统一格式（Document对象列表：List[Document]）
2. RecursiveCharacterTextSplitter 将长文本分块（chunk），确保分块后保留语义完整
3. HuggingFaceEmbeddings中的 text2vec-large-chinese模型 对chunk进行embedding，存储到向量库 FAISS（Facebook开源的向量库） 中
4. 用户查询时，查询首先变成向量的形式，在 向量库中进行相似度搜索，返回相似度 top k，大模型结合这个返回结果进行回答

#+begin_example python
# Document对象列表：List[Document]
[
    Document(
        page_content="小白的父亲是张三。",
        metadata={"source": "/root/knowledge.txt"}
    ),
    Document(
        page_content="Llama2是由Meta发布的开源大模型。",
        metadata={"source": "/root/knowledge.txt"}
    )
]
#+end_example

** （低优先级）LoRA原理
# （低秩矩阵适配）
1. *秩 代表信息量* ：秩越低则该矩阵所含信息量越少
   #+begin_comment
   [1 2 3] 这个矩阵秩为2，所含信息多
   [4 5 6]

   [1 2 3] 这个矩阵秩为1，所含信息少（第2行可以用第1行表示）
   [2 4 6]
   #+end_comment

2. *大矩阵可以分解为两个低秩矩阵* ：虽然两个低秩矩阵的信息量变少了，但是训练量也变小了
   #+begin_comment
   [ 4  5  6]   [1]
   [ 8 10 12] = [2] x [4 5 6]
   [12 15 18]   [3]
   #+end_comment

3. 训练时将原始矩阵冻结，用两个低秩矩阵A、B表示原始矩阵，并训练A、B
   推理时 =最终权重矩阵 = 原始权重矩阵 + 低秩矩阵A * 低秩矩阵B=


* Footnotes

[fn:1]
#+begin_comment 示例
上层：EchoServer
下层：TcpServer
再下层：epoll_wait
#+end_comment
