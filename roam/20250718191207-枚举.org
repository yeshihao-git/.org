:PROPERTIES:
:ID:       d091d455-5933-4047-92fb-4c2d2d2f7ff9
:ROAM_ALIASES: enum类型
:END:
#+title: 枚举
#+filetags: cpp

* 枚举
- 枚举 :: 一种[[id:763eae87-6088-40cf-874a-c3f915865734][复合数据类型]]，用 *预定义命名常量集合* 表示 *有限、离散、有语义的取值*
  1. 枚举类型 是 [[id:7178949d-e6a3-4272-90ad-7d99dd56656e][用户定义类型]] ， *使用前需要完整定义* （仅前向声明是不够的）
  2. *枚举成员都是 [[id:b06260e2-ed7a-4b12-8e9d-b07a3e564a75][constexpr]]整型常量* （在编译期确定值），枚举成员值默认从 0 开始 +1...（也可显式定义 枚举成员的值）
  3. 定义 *枚举计数器* 用于统计枚举大小（方便未来添加枚举成员、用 assert 判断枚举成员数量[fn:1]）
  4. *枚举类型是不同的类型* 无法跨枚举比较[fn:2]

*枚举分类* ：
1. [[id:1d1d0bae-f9ec-40cb-98be-5f2c10b53258][作用域枚举]]（ *Best Practice* ）
2. [[id:c93ba44b-9830-47e0-bef3-43c403be7d29][无作用域枚举]]

** 作用域枚举
:PROPERTIES:
:ID:       1d1d0bae-f9ec-40cb-98be-5f2c10b53258
:END:
- 作用域枚举 :: 有class修饰的枚举类型： =enum class=
  1. *创建了新的作用域* ，枚举成员的标识符在此作用域中
  2. *不会 隐式转换为整数*

#+begin_src cpp :results output :namespaces std :includes <iostream>
int main()
{
    enum class Color
    {
        red,         // red 在 Color作用域中
        blue,
    };

    std::cout << red << '\n';        // FIXME: red 在新作用域中
    std::cout << Color::red << '\n'; // FIXME: 作用域枚举不会隐式转换为整型 std::cout doesn't know how to print this
    Color color { Color::blue };     // okay
}
#+end_src

** 无作用域枚举
:PROPERTIES:
:ID:       c93ba44b-9830-47e0-bef3-43c403be7d29
:END:
- 无作用域枚举 :: 没有class修饰的枚举类型： =enum= [fn:3]
  1. *枚举成员暴露在当前作用域* ，可能造成命名冲突 ->（ *Best Practice* ）使用 [[id:604d5ad5-f060-4504-b407-933fc82aeb7e][命名空间]] 包裹枚举类型
  2. 可以 *隐式转换为整型*
  3. （cpp17）若 *显式指定整型的底层类型* ，以 *列表初始化* 的方式可以将 整型 隐式转换为 枚举成员 [fn:4]

* Footnotes

[fn:1]
#+name: 枚举计数器 方便未来添加枚举成员
#+begin_src cpp :results output :namespaces std :includes <iostream> <vector>
namespace Students
{
    enum Names
    {
        kenny, // 0
        kyle, // 1
        stan, // 2
        butters, // 3
        cartman, // 4
        // 这里 添加枚举成员
        max_students // NOTE 枚举计数器：当前是5 ，未来添加枚举成员，这里自动 +1
    };
}

int main()
{
    std::vector<int> testScores(Students::max_students); // 用枚举大小 初始化 vector
    testScores[Students::stan] = 76;
    std::cout << "The class has " << Students::max_students << " students\n";
    return 0;
}
#+end_src

#+RESULTS: 枚举计数器 方便未来添加枚举成员
: The class has 5 students

[fn:2]
#+begin_src cpp :results output :namespaces std :includes <iostream>
enum Color
{
    red,
    blue,
};

enum Color2
{
    red2,
    blue2,
};

int main()
{
    Color apple { red };
    Color2 apple2 { red2 };
    if (apple == apple2) {    // FIXME：无法跨枚举比较
        cout << yes << '\n';
    }
    return 0;
}
#+end_src

[fn:3]
#+begin_src cpp :results output :namespaces std :includes <iostream>
// 这个枚举定义在全局作用域
enum Color /* : std::int8_t */  //设置整型的底层类型
{
    red,   // 枚举成员 red 暴露在 全局作用域中
    blue,
};

// enum Color2
// {
//    red,  // FIXME：全局作用域中已有 red
// };

// NOTE 解决方式（Best Practice）：将枚举放入 命名空间中
namespace C {
    enum Color2
    {
        red,          // 0
        blue,         // 1
        yellow = -3,  // -3 NOTE 自定义枚举值
        green,        // -2
    };
}

int main()
{
    Color apple { red };
    // 无作用域枚举没有创建作用域，因此可以直接访问
    // 无作用域枚举会隐式转换为整型
    cout << "访问red：" << red << '\n';
    cout << "另一种方式访问red：" << Color::red <<'\n';

    cout << "命名空间访问red：" << C::red << '\n';
    cout << "另一种命名空间访问red：" << C::Color2::red << '\n';

    // Color banana {0}; FIXME：整型无法隐式转换为枚举成员
    Color banana {static_cast<Color>(0)}; // 使用 static_cast 将整型显式转换为枚举成员
    cout << "static_cast 将整型转换为枚举成员：" << banana << '\n';
}
#+end_src

[fn:4]
#+begin_src cpp :results output :namespaces std :includes <iostream>
enum Pet: int // 显式指定底层类型为int
{
    cat,   // 0
    dog,   // 1
    pig,   // 2
    whale, // 3
};

int main()
{
    Pet pet1 { 2 }; // ok: can brace initialize unscoped enumeration with specified base with integer (C++17)
    Pet pet2 (2);   // FIXME: cannot direct initialize with integer
    Pet pet3 = 2;   // FIXME: cannot copy initialize with integer
    pet1 = 3;       // FIXME: cannot assign with integer
}
#+end_src
