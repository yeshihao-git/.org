:PROPERTIES:
:ID:       9bc7f003-3c1d-4d93-abca-c98c08a61678
:END:
#+title: HTTPS
#+filetags: network

* HTTPS
- HTTPS :: 在 [[id:6cd6d820-4519-4090-8b15-4b38060fe563][HTTP]] 基础上增加了 TLS/SSL 协议的安全应用层协议
  1. 更安全，但更慢（[[id:ceed6c1f-7585-4884-874d-eb2dbf4145ae][TCP三次握手]] 后还需要 [[id:1229c0d6-2c4d-43bd-b216-3e565f5cdc4b][TLS四次握手]]）
  2. 端口： =443=
  3. 增加了SSL/TLS层：提供
     1) 加密传输：防窃听（通信建立前使用非对称加密，建立后使用对称加密）
     2) 校验机制：防篡改（摘要算法）
     3) [[id:1cc489e2-46d9-45f6-98c7-3e27b69e2a24][数字证书]]：验证服务器身份，防冒充

#+name: HTTP vs HTTPS
|-----------+------------|
| HTTP      | HTTP       |
|           | SSL/TLS    |
|-----------+------------|
| TCP       | TCP        |
|-----------+------------|
| IP        | IP         |
|-----------+------------|
| MAC       | MAC        |
|-----------+------------|


** TLS四次握手
:PROPERTIES:
:ID:       1229c0d6-2c4d-43bd-b216-3e565f5cdc4b
:END:
1. *Client Hello* ：TLS版本、支持的加密套件、第1随机数
2. *Server Hello* ：TLS版本、加密套件、第2随机数（服务端确认TLS版本、选择加密套件）
   *Certificate*  ：数字证书（内含公钥：证实服务端身份）
   *Server Hello Done* ：（表示发送完了）
   # 客户端根据 服务端数字证书的签发者 找到中间CA
   # 根据 中间CA数字证书的签发者 找到根CA
   # 用预先存放在浏览器/操作系统根CA公钥 验证 中间CA数字证书，验证成功后，用中间CA公钥 验证 服务器数字证书 -> 服务器公钥可信
3. *Client Key Exchange* ：服务器公钥加密的预主密钥                       -> [[id:725b96ad-670f-4ae8-b681-dcf357f0f1f5][非对称加密]]
   # 服务端用私钥解密 -> 得到预主密钥
   客户端、服务端用 第1随机数、第2随机数、预主密钥 -> 得到 会话密钥
   *Change Cipher Spec* ：告诉服务器，开始使用会话密钥加密通信            -> [[id:6156bb5b-0b9b-401e-9350-b2082f86609b][对称加密]]
   *Finished* ：所有握手数据的摘要，供服务器校验
   # 服务端 解密摘要，验证是否一致，若一致发送以下内容
4. *Change Cipher Spec* ：告诉客户端，开始使用会话密钥加密通信
   # 数据传输阶段：经过会话密钥加密后的 数据+摘要算法（基于摘要的MAC）
   *Finished* ：所有握手数据的摘要，供客户端校验


*** 🖼 TLS四次握手 :ATTACH:
:PROPERTIES:
:ID:       aac5ee6b-3e88-488f-afa1-66f43b5278cc
:END:
[[attachment:_20250821_131128screenshot.png]]


** 对称加密、非对称加密
*** 对称加密
:PROPERTIES:
:ID:       6156bb5b-0b9b-401e-9350-b2082f86609b
:END:
- 对称加密 ::  加密解密使用同一把密钥，加密解密的速度快，安全性较低（在网络中传递密钥，容易被偷，导致数据安全无法得到保障）
#+begin_example
你给我密钥，我把密钥加密后的数据给你，中间人偷到密钥，中间人能解密
#+end_example


*** 非对称加密
:PROPERTIES:
:ID:       725b96ad-670f-4ae8-b681-dcf357f0f1f5
:END:
- 非对称加密 :: 加密解密使用一对密钥，公钥可以公开传播，私钥必须保密（公钥/私钥 加密，私钥/公钥 解密），加密解密的速度慢，安全性高（在网络中传递公钥，安全）
#+begin_example
你给我公钥，我把公钥加密后的数据给你，中间人偷到公钥，中间人无法解密
#+end_example


** 数字证书（图文） :ATTACH:
:PROPERTIES:
:ID:       1cc489e2-46d9-45f6-98c7-3e27b69e2a24
:END:
[[attachment:_20260114_145205screenshot.png]]
*服务端申请数字证书* ：
1. 服务端将公钥和自己相关的信息交给 中间CA，中间CA 用这些信息计算出hash值，再用自己的私钥加密，生成 数字签名，
2. 中间CA 向 根CA 申请数字证书同理：根CA 计算 中间CA 数字证书的哈希值，用自己的私钥加密，得到 中间CA 数字证书的数字签名
3. 根CA 也用自己的私钥自签名，将自己的数字证书 安装到客户端的浏览器/操作系统中
   - 数字证书 :: 由 CA 签发的、用于验证通信实体身份和公钥合法性的电子文档（ =数字证书 = 数字签名 + 公钥A + 服务端相关信息= ），可以形成 [[id:a8ea7045-3bf8-4922-91f8-802b197ee06d][🖼 证书链]]
   - 数字签名 :: 证明数字证书的有效性
   - CA :: 证书颁发机构
#+name: 为什么需要CA？
#+begin_comment
背景：你发布公钥A，先给到中间人，中间人不给我，中间人将自己的公钥B给我，我用公钥B加密后，中间人用它的私钥B解密出真实内容，又用公钥A加密后给你，你用私钥A解密发现正确，于是建立了：我-中间人-你 这样的连接
因此我们需要第三方解决公钥信任问题，也就是 证书颁发机构（CA）
你把公钥放到大家都信任的CA那里，CA根据公钥和其他信息生成 数字证书，你把数字证书给我，我发现是信任的CA，于是我取出公钥...
#+end_comment

#+name: 为什么根CA不直接颁发证书？
#+begin_comment
假设只有根CA，根CA失守了，整个信任链都会有问题；
有中间CA的情况，中间CA失守，问题不大
#+end_comment


*** 🖼 证书链 :ATTACH:
:PROPERTIES:
:ID:       a8ea7045-3bf8-4922-91f8-802b197ee06d
:END:
[[attachment:_20260114_145025screenshot.png]]
