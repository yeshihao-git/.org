:PROPERTIES:
:ID:       58957271-3fa8-40bc-9140-010e1c8eb91e
:END:
#+title: mysql锁
#+filetags: mysql

* mysql锁 [[https://xiaolincoding.com/mysql/lock/mysql_lock.html#%E5%85%A8%E5%B1%80%E9%94%81][小林coding]]
*实践方式*
- 悲观锁 ::
  1. 默认冲突，操作前加锁；适用 写多读少 场景（eg：商品秒杀）
- 乐观锁 ::
  1. 默认无冲突，操作结束后检查 版本号/时间戳，冲突则重试；适用 读多写少 场景（eg：改文章、改商品信息）

*操作类型*
- 共享锁（读锁） :: 读读共享，读写互斥
- 独占锁（写锁） :: 写写互斥，读写互斥
#+begin_example sql
/* 加读锁 */ lock in share mode
/* 加写锁 */ for update
#+end_example

*锁的粒度*
- 全局锁 :: 锁整个数据库
- 表级锁 :: 锁整张表
- 行级锁 :: 锁单行数据

** 全局锁
用于 *备份数据库* ，使整个数据库的处于 "只读状态"
（MyISAM存储引擎，InnoDB存储引擎这种支持「可重复读隔离级别的事务」，推荐用 mysqldump --single-transaction 基于 MVCC 实现 “无锁全量备份”，无需依赖全局锁，避免阻塞业务写操作）
#+begin_example sql
flush tables with read lock // 加全局锁
unlock tables               // 解全局锁
#+end_example

** 表级锁
*表锁*
锁住整张表。结合读写锁：
1. 表读锁（S锁）：加S锁，其他事务能加S锁，但不能加X锁 -> 保证 *多事务读效率*
2. 表写锁（X锁）：加X锁，其他事务不能加S锁、X锁       -> 保证 *写操作原子性*
#+begin_example sql
lock tables t_student read; // 读锁，也就是 表级别的共享锁
                            // 当前会话 可读不可写；上锁期间只能读该表，不能读其他表
                            // 其他会话 可读不可写（会话就是当前的连接，线程只是处理会话请求的临时工）

lock tables t_stuent write; // 写锁，也就是 表级别的独占锁
                            // 当前会话 可读写；上锁期间只能读写该表，不能读写其他表
                            // 其他会话 不可读写

unlock tables               // 解所有表锁
#+end_example

*元数据锁（MDL）*
事务执行中，防止 *表结构* 被修改；具体来说
1. 事务进行 数据操作（select/insert/update/delete）自动加 MDL读锁
2. 事务进行 表结构操作（alter table/drop table）   自动加 MDL写锁
原则还是 =读读共享，写写互斥，读写互斥=

*自增锁（AUTO-INC锁）*
用于保证 带有 AUTO_INCREMENT属性的字段 连续增加；具体来说
1. 插入记录时，加一个表级别 AUTO-INC锁，插入完成释放，在此期间其他事务无法向该表插入数据

*意向锁*
表级锁，用于告知其他事务当前表中是否有行级锁；具体来说
1. 对表中某个记录加读锁（S）时，会自动在表级别加 读意向锁（IS）；此时其他事务只能加表级读锁
2. 对表中某个记录加写锁（X）时，会自动在表级别加 写意向锁（IX）；此时其他事务不能加表级读锁、写锁

** 行级锁
# InnoDB引擎支持，MyISAM引擎不支持
*记录锁（Record Lock）*
给单行记录加锁，相比表锁 粒度细、并发性能高
读读共享、读写互斥、写写互斥

*间隙锁（Gap Lock）*
锁定记录间的间隙，不锁定记录；防止插入数据 -> 防止幻读
#+begin_example sql
表中存在 间隙锁 (3, 5)
那么其他事务无法插入 id=4 这条记录
#+end_example

*临键锁（Next-Key Lock = Record Lock + Gap Lock）*
锁定记录间的间隙，锁定记录；防止插入修改、数据 -> 防止幻读、写冲突
#+begin_example sql
表中存在 临键锁 (3, 5]
其他事务不能插入 id=4 的记录，也不能修改 id=5 这条记录
#+end_example

-------------------------------------------------------------------------------------------------------------------------------

*插入意向锁*
往同一间隙插数据的多个事务，只要插的位置不同，就能同时插入，否则排队等锁，提高并发效率
#+begin_example
假设表中有数据 id=10 和 id=20，中间有个 间隙（10,20）
- 事务 A 想插 id=15，会先尝试在（10,20）间隙加 插入意向锁，若该间隙没被其他事务上间隙锁，则插数据，否则阻塞，等待间隙锁释放
- 同时事务 B 想插 id=18，也会检查（10,20）间隙的锁：发现 A 的插入位置（15）和自己的（18）不冲突，就也能加 插入意向锁，和 A 同时插，不用等 A 插完
- 但如果事务 C 想插 id=15（和 A 位置重叠），就会被 A 的锁挡住，必须等 A 结束才能插。
#+end_example
