:PROPERTIES:
:ID:       878bbff5-6362-4cf9-ab1c-15bc1849cd79
:END:
#+title: 指针
#+filetags: cpp

* 指针
- 指针 :: 是一个 [[id:4276f9fb-4b68-4c73-bd8f-8a7c1e5f82a9][变量]] ，存储其他 变量/函数 的 *地址*
  1. *可初始化* ， *后续能改变指向对象*
  2. 指针需要和 *被指对象类型一致* ，如果不同，会报错，除非某些特定情况...
  3. 指针 *大小* 在 32位系统为 4字节、64位系统为 8字节

#+name: 指针总结
|-----------+-------------------------------------------|
| 指针      | 定义                                      |
|-----------+-------------------------------------------|
| 野指针    | 未初始化的指针                            |
| 悬空指针  | 被指对象 在 指针 之前销毁，会导致[[id:6782179f-792b-4eb6-807c-4f95aba88169][内存泄漏]] |
| [[id:6acf0727-89af-4954-a8fb-1fc5b215c93e][空指针]]    | 指向任意类型的指针                        |
| [[id:d3f3f997-867e-437f-b062-7cfca7ec5a19][const指针]] | 指针常量、常量指针                        |
| 数组指针  | C风格数组 退化而来                        |
| [[id:e911b690-49b8-4106-a902-2a5e632d036d][函数指针]]  | 指向函数的指针                            |
| [[id:7cb0d4aa-e74a-4563-acf6-053e129105e9][智能指针]]  | 自动管理资源的生命周期                    |
|-----------+-------------------------------------------|


** 空指针
:PROPERTIES:
:ID:       6acf0727-89af-4954-a8fb-1fc5b215c93e
:END:
- 空指针 :: （ =void*= ）指向任意类型的指针 [fn:1]，需要[[id:a5cc8359-125f-45a2-8901-4858134c09c3][强制类型转换]]后解引用
  1. 现代用法： =nullptr=
     古代用法：NULL、0（可能 *被误认为整型* ，导致 [[id:a545a441-471f-45d4-8a7b-30767486357a][函数重载]] 歧义 [fn:2]）
  2. 解引用空指针：强制类型转换为其他指针类型，再解引用 [fn:3]

- void :: 特殊空类型，是一个声明但没有定义的类型，编译器知道这是一个类型，但不知道分配多少内存。用于不返回值的函数


** 指针常量、常量指针
:PROPERTIES:
:ID:       d3f3f997-867e-437f-b062-7cfca7ec5a19
:ROAM_ALIASES: const指针
:END:
- 指针常量 :: 指针是const的  -> 指向不可变，指向的值可变
  1. 必须初始化
- 常量指针 :: 指向常量的指针 -> 指向可变，指向的值不可变
#+begin_src cpp
/* NOTE const修饰规则：先左后右 */
const int*       // 指向 const int 的指针（指针常量）
int const *      // 指向 const int 的指针（指针常量）
int* const       // 指向 int 的 const指针（常量指针）
const int* const // 指向 const int 的 const指针（指针常量 + 常量指针）
#+end_src


** 函数指针
:PROPERTIES:
:ID:       e911b690-49b8-4106-a902-2a5e632d036d
:END:
- 函数指针 :: 指向函数的指针
  1. 常用 [[id:15357ed3-3530-4c07-b743-9af983e05e96][类型别名]] 简化使用 [fn:11]
  2. （cpp11）可以用 =std::function= 包装 *函数指针* 简化使用，只允许隐式解引用 [fn:22]
  3. 函数指针 *调用函数* [fn:33]
     1) 显式解引用
     2) 隐式解引用
  4. *使用场景*
     1) 回调函数（作为函参）
     2) 将函数存到 数组
#+begin_src cpp
/* 函数指针 */
int (*fcnPtr)(int);

/* 初始化、赋值 */
int foo(int){}
int goo(int){}

int (*fcnPtr2)(int){ &foo }; // 初始化：fcnPtr2 指向 foo函数
// auto fcnPtr2 { &foo };       NOTE auto 简化 函数指针初始化
fcnPtr2();                   // NOTE 函数调用

fcnPtr2 = &goo;              // 赋值：fcnPtr2 指向 goo函数
// fcnPtr2 = goo();             FIXME 这是尝试将 goo的返回值赋给 fcnPtr2
#+end_src


* Footnotes

[fn:1]
#+begin_src cpp
int nValue {};

float fValue {};

struct Something
{
    int n;
    float f;
};
Something sValue {};

void* ptr {};
ptr = &nValue; // ok
ptr = &fValue; // ok
ptr = &sValue; // ok
#+end_src

[fn:2]
#+begin_src cpp :results output :namespaces std :includes <iostream>
#include <cstddef> // for NULL

void print(int x) // this function accepts an integer
{
  std::cout << "print(int): " << x << '\n';
}

void print(int* ptr) // this function accepts an integer pointer
{
  std::cout << "print(int*): " << (ptr ? "non-null\n" : "null\n");
}

int main()
{
  int x{ 5 };
  int* ptr{ &x };

  print(ptr);  // always calls print(int*) because ptr has type int* (good)
  print(0);    // always calls print(int) because 0 is an integer literal (hopefully this is what we expected)

  print(NULL); // this statement could do any of the following:
  // call print(int) (Visual Studio does this)
  // call print(int*)
  // result in an ambiguous function call compilation error (gcc and Clang do this)

  print(nullptr); // always calls print(int*)

  return 0;
}
#+end_src

[fn:3]
#+begin_src cpp
int value{ 5 };
void* voidPtr{ &value };
// std::cout << *voidPtr << '\n';          // FIXME 解引用空指针非法

int* intPtr{ static_cast<int*>(voidPtr) }; // NOTE 强制类型转换为 int 指针类型
std::cout << *intPtr << '\n';              // 可以解引用了
#+end_src

[fn:11]
#+begin_src cpp
int foo_int(int x) {
  return x + 1;
}

using Ptr = int (*)(int);    // NOTE 类型别名 简化使用
Ptr p { foo_int };           // 初始化
p(1);                        // 调用函数
#+end_src

[fn:22]
#+begin_src cpp :results output :namespaces std :includes <iostream> <functional>
int foo() { return 5; }
int goo(){ return 6; }

int main() {
    std::function<int()> fcnPtr{ &foo }; // 定义+初始化 函数指针
    fcnPtr = &goo;                       // fcnPtr 指向 goo函数
    std::cout << fcnPtr() << '\n';       // NOTE 调用函数 std::function 只允许隐式解引用
    std::function fcnPtr2{ &foo };       // CTAD 推导模板参数
}
#+end_src

[fn:33]
#+begin_src cpp :results output :namespaces std :includes <iostream>
int foo(int x) { return x; }

int main() {
    int (*fcnPtr)(int){ &foo };   // 初始化：fcnPtr 指向函数 foo
    cout << (*fcnPtr)(5) << '\n'; // NOTE 显式解引用调用 foo(5)
    cout << fcnPtr(6) << '\n';    // NOTE 隐式解引用调用 foo(6)
}
#+end_src
