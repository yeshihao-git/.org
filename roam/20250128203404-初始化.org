:PROPERTIES:
:ID:       819c9ef5-5220-4678-994a-3122d7d17ab7
:END:
#+title: 初始化
#+filetags: cpp

* 初始化
*现代初始化* ：
1. 列表初始化 ={}= -引出-> 直接列表初始化、拷贝列表初始化、值初始化

*古代初始化* ：
1. 直接初始化 =()=
2. 拷贝初始化 ===
3. 默认初始化（没有初始化值的是）
#+begin_src cpp :results output :namespaces std :includes <iostream>
// 列表初始化（现代）
int d {};      // 值初始化：0... (empty braces)
int e { 7 };   // 直接列表初始化 (initial value in braces)
int f = { 6 }; // 拷贝列表初始化

// 初始化（古代）
int a;         // 默认初始化：随机值 (no initializer)
int b = 5;     // 拷贝初始化 (initial value after equals sign)
int c ( 6 );   // 直接初始化 (initial value in parenthesis)
#+end_src

** 列表初始化
:PROPERTIES:
:ID:       c794bd12-f733-4f8d-99cb-b34555506975
:END:
- 列表初始化 :: （cpp11）使用 花括号 ={}= 进行的初始化方式，统一了不同场景的初始化
  1. 不允许 [[id:1c7e9842-2dee-43ce-a9cb-94672516adb3][窄化转换]] [fn:1]
  2. 支持聚合类型/非聚合类型初始化
  3. 无初始化值的初始化 会进行 值初始化（更统一）： =0= 、 =nullptr= 、 =类默认构造=

*** 本质
当编译器看到一个初始化列表（和列表初始化不是一个东西），会将其转换为 std::initializer_list 类型的对象，只要类中有接收 std::initializer_list 的 [[id:fabc592f-3ef4-4ea3-9700-abfc4300f73b][初始化列表构造函数]] ，就能用 列表初始化


* Footnotes
[fn:1]
#+begin_src cpp :results output :namespaces std :includes <iostream>
int w1 { 4.5 }; // FIXME: 列表初始化 不允许 窄化转换
int w2 = 4.5;   // compiles: w2 copy-initialized to value 4
int w3 (4.5);   // compiles: w3 direct-initialized to value 4
#+end_src
