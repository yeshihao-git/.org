:PROPERTIES:
:ID:       12e4e623-53bd-4b85-8167-16a75a03bb6f
:ROAM_ALIASES: cpp实现线程同步
:END:
#+title: C++实现线程同步
#+filetags: cpp

* C++实现线程同步
- 互斥量   :: 用于保护资源，确保同一时间只有一个线程能访问（互斥）
- 条件变量 :: 搭配互斥量使用，用于线程间的等待和通知（同步）
- 原子操作 :: 不使用锁的情况下，对数据的读写是原子的（读写的过程中不会被打断）

*互斥量*
std::mutex                ：普通互斥量
std::recursive_mutex      ：递归互斥量
std::timed_mutex          ：定时互斥量
std::recursive_timed_mutex：递归定时互斥量

*锁包装器*
# 利用RAII机制（根据类的生命周期自动加锁、自动解锁）封装互斥量，简化锁的使用
std::lock_guard
std::unique_lock

*条件变量*
std::condition_variable：搭配 std::unique_lock 实现同步（线程获得锁并查看是否满足条件，不满足则释放锁，进入睡眠状态，等待被唤醒后重新获得锁，满足则继续执行临界区操作）[fn:1]

*原子操作*
std::atomic


* Footnotes

[fn:1]
#+begin_src cpp :results output :namespaces std :includes <iostream>
#include <thread>
#include <mutex>
#include <condition_variable>

std::mutex mtx;
std::condition_variable cv;
bool ready = false;

// 等待条件满足的线程
void wait_thread() {
    std::unique_lock<std::mutex> lock(mtx);
    cv.wait(lock, []{ return ready; }); // 等待直到ready为true
    std::cout << "收到通知，开始工作\n";
}

// 发送通知的线程
void notify_thread() {
    std::this_thread::sleep_for(std::chrono::seconds(1)); // 模拟准备工作
    {
        std::lock_guard<std::mutex> lock(mtx);
        ready = true; // 更新条件
    }
    std::cout << "准备完毕，发送通知\n";
    cv.notify_one(); // 唤醒等待的线程
}

int main() {
    std::thread t1(wait_thread);
    std::thread t2(notify_thread);

    t1.join();
    t2.join();
    return 0;
}

#+end_src

#+RESULTS:
: 准备完毕，发送通知
: 收到通知，开始工作
