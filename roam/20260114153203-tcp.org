:PROPERTIES:
:ID:       2734ca58-d8c8-48e3-a490-1aed5467b9b5
:END:
#+title: TCP
#+filetags: network

* TCP
- TCP :: 一种面向连接、可靠的、基于字节流的传输层协议


** TCP vs UDP
*** TCP（图文） :ATTACH:
:PROPERTIES:
:ID:       280b2720-57db-42c5-b046-863cae2e50a4
:END:
[[attachment:_20250806_142052screenshot.png]]
1. *应用场景*   ：可靠性优先场景（eg：文件传输、网页浏览、电子邮件）
2. *面向连接*   ：传输数据前需要建立连接（[[id:ceed6c1f-7585-4884-874d-eb2dbf4145ae][TCP三次握手]] 建立连接，结束传输 [[id:a9a65a40-fc21-4c71-925e-291763a06f35][TCP四次挥手]]）-> TCP头部的 标志位（SYN、ACK、FIN）
3. *可靠*       ：有序接收、无丢失（序号机制、[[id:43b15fcd-d58b-4d06-aa11-ba1cea9964a9][TCP重传机制]]、数据校验）                 -> TCP头部的 序列号、确认应答号、校验和、选项:SACK
4. *面向字节流* ：无消息边界，存在[[id:a1cc3035-80d0-41d7-a846-a8657b8dbf9d][粘包问题]]
5. *流量控制*   ：控制发送方发送速度，以匹配接收方数据处理能力（[[id:38f5ad84-add1-40ab-a0ff-2ef0c81d59f2][TCP滑动窗口机制]]）     -> TCP头部的 窗口大小
6. *[[id:63a8feff-fff9-4e50-8a8a-260fb5158ac4][拥塞控制]]*   ：控制发送方发送速度，防止网络拥堵（慢启动、拥塞避免、拥塞发生、快速恢复）

7. *首部大小*   ：20字节（使用选项时 > 20）
8. *分片方式*   ：在 传输层 基于 =MSS= 分片
9. *服务对象*   ：一对一


*** UDP（图文） :ATTACH:
:PROPERTIES:
:ID:       1a74e463-f101-4de1-a339-a857ea624856
:END:
[[attachment:_20250806_142800screenshot.png]]
1. *应用场景* ：实时性和效率优先场景（因为速度快；eg：语音通话）
2. *无连接*   ：直接传输数据，无需建立连接（三次握手和四次挥手）
3. *不可靠*   ：尽最大可能交付，不保证无丢失、按序到达
4. *面向报文* ：有消息边界（一个报文一个消息，天然的有消息边界）
5. *无流量控制*
6. *无拥塞控制*

7. *首部大小* ：8字节
8. *分片方式* ：在 网络层 基于 =MTU= 分片
9. *服务对象* ：一对一、一对多


** TCP三次握手（图文） :ATTACH:
:PROPERTIES:
:ID:       d1f3066e-da66-47d4-b535-20f7a925ca87
:END:
[[attachment:_20250805_094902screenshot.png]]

*作用*
同步双方序列号（有序收发）
验证双方收发能力没问题

*流程*
1. 客户端  ---发送 =SYN 报文= ，序列号 =seq=x= --->  服务器
   进入 =SYN_SENT= 状态 -> 说明客户端发送没问题

2. 服务器  ---发送 =SYN-ACK 报文= ，序列号、确认号 =seq=y, ack=x+1= --->  客户端
   进入 =SYN_RCVD= 状态 -> 说明服务器发送和接收没问题

3. 客户端  ---发送 =ACK 报文= ，序列号、确认号 =seq=x+1, ack=y+1= --->  服务器
   双方进入 =ESTABLISHED= 状态 -> 说明客户端接收没问题（此阶段可以发送数据）

#+begin_comment
标识位 SYN、ACK：用于标识报文的类型（同步报文、确认报文）
#+end_comment

- 半连接队列（SYN队列）    :: 第一次握手时，将 socket 放入该队列（队列中 socket 为 SYN_RECV 状态）
- 全连接队列（ACCEPT队列） :: 第三次握手时，将 socket 从半连接队列取出，放入全连接队列（队列中 sock 为 ESTABLISHED 状态），等待服务端 =accept()=


*** 为什么是三次握手而不是两次握手？
- 避免历史连接     :: 两次握手情况下，网络延迟的历史客户端SYN包在连接关闭后被服务端接收，服务端认为这是一个新的连接请求，返回 SYN-ACK包后建立连接，服务端可以发送数据，客户端判断到此次连接是历史连接，于是返回RST报文来断开连接，服务端收到RST报文后断开连接，但服务端在这期间可能发送了数据，造成服务端资源浪费
- 确保双方收发能力 :: 两次握手情况下，服务端无法知道客户端是否收到 SYN-ACK包，也就无法确定客户端是否有接收能力
- 同步双方序列号   :: 两次握手只同步了客户端的序列号，没有同步服务端的序列号


*** 为什么是三次握手而不是四次握手？
三次握手已足够，四次握手增加建立连接的开销


*** 什么是 SYN Flood 攻击？如何避免？（图文） :ATTACH:
:PROPERTIES:
:ID:       77bbfdac-f6d4-487c-8ebd-9c572840f518
:END:
[[attachment:_20250807_094405screenshot.png]]
*SYN Flood 攻击* ：攻击者发送大量 SYN报文 占满 半连接队列，导致服务端无法接收新的 SYN请求
*避免* ：使用 =tcp_syncookies= 绕过 半连接队列 直接 accept 连接：第一次握手，服务端不会将 sock 放入半连接队列，而是生成 cookies；第二次握手带上 cookies；第三次握手带上 cookies，服务端验证 cookies是不是之前发的那个，若是，则建立连接放入 全连接队列

📎 [[https://www.xiaolincoding.com/network/3_tcp/tcp_no_accpet.html#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E7%9A%84%E7%BB%86%E8%8A%82%E5%88%86%E6%9E%90][小林coding]]


*** TODO tmp

**** 已建立连接但客户端突然断电怎么办？ [[https://www.xiaolincoding.com/network/3_tcp/tcp_interview.html#%E5%A6%82%E6%9E%9C%E5%B7%B2%E7%BB%8F%E5%BB%BA%E7%AB%8B%E4%BA%86%E8%BF%9E%E6%8E%A5-%E4%BD%86%E6%98%AF%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%AA%81%E7%84%B6%E5%87%BA%E7%8E%B0%E6%95%85%E9%9A%9C%E4%BA%86%E6%80%8E%E4%B9%88%E5%8A%9E][小林coding]]
在一个时间段内没有任何交互，启动 *TCP保活机制* ，服务端每隔段时间发送一个探测报文，都没得到响应则TCP连接死亡；但保活机制的持续时间有点长（2个多小时），我们可以在 *应用层实现一个心跳机制*


**** 已建立连接但服务端进程崩溃会发生什么？ [[https://www.xiaolincoding.com/network/3_tcp/tcp_interview.html#%E5%A6%82%E6%9E%9C%E5%B7%B2%E7%BB%8F%E5%BB%BA%E7%AB%8B%E4%BA%86%E8%BF%9E%E6%8E%A5-%E4%BD%86%E6%98%AF%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%9A%84%E8%BF%9B%E7%A8%8B%E5%B4%A9%E6%BA%83%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88][小林coding]]
TCP连接信息由内核维护，四次挥手也是在内核中完成，无需进程参与 -> 因此就算服务端进程退出，还是能与客户端完成TCP四次挥手


**** 没有 accept 可以建立 TCP连接吗？
可以，使用 =tcp_syncookies= ，见：[[id:77bbfdac-f6d4-487c-8ebd-9c572840f518][什么是 SYN Flood 攻击？如何避免？ :ATTACH: 小林coding]]


**** 没有 listen 可以建立 TCP连接吗？ [[https://www.xiaolincoding.com/network/3_tcp/tcp_no_listen.html#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90][小林coding]]
可以。客户端可以自连接，也可以两个客户端同时向对方请求建立连接
*分析* ：服务端 listen 会建立 半连接队列、全连接队列，用于存放连接信息；因此要形成连接，只要有地方存放连接信息就行 -> 内核有一个 *全局hash表* ，可以存放 socket 连接信息
#+begin_example
以TCP自连接为例：客户端 connect 时，会将连接信息放入 全局hash表中，将信息发出，信息通过回环地址回到 TCP传输层，根据 IP+端口信息 再次从 全局hash 中取出信息，建立连接
#+end_example


** TCP四次挥手（图文） :ATTACH:
:PROPERTIES:
:ID:       0e2cdec4-1d24-4be2-92ef-62058f1510fb
:END:
[[attachment:_20250805_101611screenshot.png]]

*作用*
关闭TCP连接

*流程*
# 主动关闭方以客户端为例
1. 客户端打算关闭连接， =FIN= 报文，客户端进入 =FIN_WAIT_1= 状态
2. 服务端收到该报文后，就向客户端发送 =ACK= 应答报文，接着服务端进入 =CLOSE_WAIT= 状态
   客户端收到服务端的 =ACK= 应答报文后，之后进入 =FIN_WAIT_2= 状态
3. 等待服务端处理完数据后，也向客户端发送 =FIN= 报文，之后服务端进入 =LAST_ACK= 状态
4. 客户端收到服务端的 =FIN= 报文后，回一个 =ACK= 应答报文，之后进入 =TIME_WAIT= 状态，等待 2MSL 后进入 =CLOSE= 状态（客户端收到FIN后发送ACK开始计时，又收到重发的FIN，重置2MSL）
   服务端收到了 =ACK= 应答报文后，就进入了 =CLOSE= 状态，至此服务端已经完成连接的关闭


*** 为什么需要四次挥手？
因为被动关闭方（eg：服务端），可能还有数据需要处理或发送，因此 仅发送 =ACK= 报文表示确认，等处理完，才会发送 =FIN= 报文表示同意关闭连接


*** TIME_WAIT等待时间为什么是 2MSL？ / 为什么挥手需要 TIME_WAIT 状态？ :ATTACH:
:PROPERTIES:
:ID:       ae96f81e-fb9f-4c52-8f42-14b5dea2e357
:END:
1. *保证被动关闭方能正确关闭*
   =MSL= 代表报文在网络中的存在的最长时间， =2MSL= 覆盖 发送方和接收方数据包一次来回的时间，确保服务端能收到 =ACK报文= ，就算没收到，客户端也能等到服务端重发的 =FIN报文=
    - MSL(报文最大生存时间) :: =MSL= 代表报文在网络中的存在的最长时间

2. *保证历史连接中的报文都消失* -> 防止污染同[[id:abf2d234-abd2-4248-8d10-cdf4fb849432][TCP四元组]]的新连接
   =2MSL= 的时间足够让历史连接中两个方向的数据包在网络中自然消失，防止下一个连接收到历史报文，造成数据混乱
#+begin_example
假设上一个连接（TCP四元组A）和下一个连接（TCP四元组B）的四元组相同：A=B； 上一个连接服务端发送的历史数据包a被网络延迟，A释放连接（没有TIME_WAIT时间过短或没有），下一个连接立刻建立后接收数据包a（因为包中的序列号是循环的，会绕回初始值，因此没法通过序列号判断 数据包a 是历史数据），造成数据混乱
#+end_example
[[attachment:_20250806_204653screenshot.png]]

📎 [[https://www.xiaolincoding.com/network/3_tcp/tcp_interview.html#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-time-wait-%E7%8A%B6%E6%80%81][小林coding]]


*** TIME_WAIT过多有什么危害？如何优化？
1. *危害* ：占用资源：fd、端口、内存、CPU等
2. *优化* ：
   1) 如果是HTTP使用 短连接 导致的，就改用[[id:509b7100-a51d-4433-a5d2-0795fb2dcb60][长连接]]
   2) 修改内核参数： =/etc/sysctl.conf=
      - net.ipv4.tcp_tw_reuse=1     :: （客户端用） 调用 connect() 时，随机复用 TIME_WAIT 时间超过一秒的连接
      - net.ipv4.tcp_max_tw_buckets :: （默认18000）超过这个选项值的 TIME_WAIT连接 会被关闭
      #+end_src
   3) 避免 =TIME_WAIT= （避免成为主动关闭方）
#+begin_example
服务端要避免过多 TIME_WAIT 就不要主动断开连接（主动断开的才有 TIME_WAIT 状态）让分布各处的客户端去承受 TIME_WAIT
#+end_example

📎 [[https://www.xiaolincoding.com/network/3_tcp/tcp_interview.html#time-wait-%E8%BF%87%E5%A4%9A%E6%9C%89%E4%BB%80%E4%B9%88%E5%8D%B1%E5%AE%B3][小林coding]]


** TCP流量控制
:PROPERTIES:
:ID:       848929bc-0724-437f-b514-7e23025ba75d
:END:
基于 [[id:98dd854e-6652-48de-b131-28dad26106d6][滑动窗口机制]] 实现，在通信过程中，接收方根据自己的 =rwnd= 的大小动态调整发送方的发送窗口大小， =swnd = min(cwnd, rwnd)= -> 不考虑拥塞控制：swnd = rwnd； 不考虑流量控制：swnd = cwnd
- *swnd* ：[[id:b54196fa-03f0-457e-8cd5-b7e26aafe49b][发送窗口]]
- *rwnd* ：[[id:21a61071-08b5-4670-8142-91f0c447a045][接收窗口]]
- *cwnd* ：拥塞窗口

📎 [[https://www.bilibili.com/video/BV1ju4y1G7wB/?vd_source=4441bc96046659b39d059d583f36ff52][bilibili-编程十万问]]


*** 滑动窗口机制
:PROPERTIES:
:ID:       98dd854e-6652-48de-b131-28dad26106d6
:END:
1. *作用* ：
   1) 提高发送效率（慢：停止等待协议）
      - 停止等待协议：发送一个数据，等到确认才发下一个
      - 滑动窗口    ：无需等待确认，在一个窗口内可连续发送数据
   2) 控制发送方速率，以匹配接收方数据处理能力
      - 滑动窗口    ：接收方通过 TCP头的窗口大小字段 告诉发送方自己能处理的数据量


**** 🖼 发送窗口 :ATTACH:
:PROPERTIES:
:ID:       b54196fa-03f0-457e-8cd5-b7e26aafe49b
:END:
[[attachment:_20250806_164213screenshot.png]]
可用窗口大小 = SND.WND - (SND.NXT - SND.UNA)
- SND.WND = min(cwnd, rwnd)：🔥 发送窗口大小 = min(拥塞窗口,接收窗口)
- SND.NXT                  ：未发但可发的第一个字节
- SND.UNA                  ：已发但未确认的第一个字节


**** 🖼 接收窗口 :ATTACH:
:PROPERTIES:
:ID:       21a61071-08b5-4670-8142-91f0c447a045
:END:
[[attachment:_20250806_164255screenshot.png]]
- RCV.WND：接收窗口大小（记录到 TCP头的窗口大小字段，发给发送方）
- RCV.NXT：期望发送方发来的下一个数据


** TCP拥塞控制
:PROPERTIES:
:ID:       ee4c5b35-4ca3-4db7-9904-44e4585522f7
:END:
- 拥塞控制 :: 用于控制发送方发送速度， *防止网络拥堵* 。具体做法：发送方维护 =拥塞窗口cwnd= 根据网络拥塞程度动态变化

拥塞控制四个阶段：
1. *慢启动*  ：发送 cwnd 大小数量的数据，每收到一个 ACK，cwnd+1；当达到 =ssthresh（慢启动门限）= 进入 *拥塞避免*
   #+begin_example
   cwnd = 1，发送1个，ACK1个 -> cwnd + 1 = 2
   cwnd = 2，发送2个，ACK2个 -> cwnd + 2 = 4
   cwnd = 4，发送4个，ACK4个 -> cwnd + 4 = 8
   ...
   #+end_example

2. *拥塞避免* ：发送 cwnd 大小数量的数据，收到等量 ACK，cwnd+1；网络拥塞导致重传时，进入 *拥塞发生*
   #+begin_example
   cwnd = 8，发送8个，ACK8个 -> cwnd + 1 =9
   cwnd = 9，发送9个，ACK9个 -> cwnd + 1 =10
   ...
   #+end_example

3. *拥塞发生* ：
   1) 超时重传：（说明网络拥塞严重）ssthresh变成cwnd一半，cwnd重置为1，进入 *慢启动*
   2) 快速重传：（说明网络拥塞较重）ssthresh、cwnd都变为cwnd一半，进入 *快速恢复*

4. *快速恢复* ：
   发送方重传丢失的数据包
   因为已收到3个重复的ACK（由于快速重传），cwnd + 3；若每次再收到重复ACK，cwnd + 1
   若收到新ACK，表示重传成功，cwnd = ssthresh，进入 *拥塞避免*


*** 🖼 拥塞控制 :ATTACH:
:PROPERTIES:
:ID:       d38ca0fc-847d-4de5-b01d-e3673ddf3a05
:END:
[[attachment:_20250806_174750screenshot.png]]


** TCP粘包和拆包
:PROPERTIES:
:ID:       6aa0c72a-dfb6-4c80-a1f1-fc0b063a2da5
:END:
- 粘包 :: 发送方的用户消息 可能被系统拆分成 多个 TCP报文进行传输，但接收方 *不知道用户消息的开始和结束边界*
#+begin_comment
因此我们说TCP是面向字节流传输的，因为一个TCP报文不对应一个完整的用户消息
#+end_comment

- 拆包 :: 两种方式
  1. *自定义消息结构* ：消息头+消息体（消息头长度固定，用于说明后边消息体中的数据长度）
  2. 在用户消息之间插入 *特殊字符作为边界* （eg：[[id:6cd6d820-4519-4090-8b15-4b38060fe563][HTTP]]用 回车+换行 作为边界）

📎 [[https://www.xiaolincoding.com/network/3_tcp/tcp_stream.html#%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E5%AD%97%E8%8A%82%E6%B5%81][小林coding]]


** TCP重传机制
:PROPERTIES:
:ID:       6645c4cd-e1bd-43d4-af47-0534872f8b83
:END:
- TCP重传机制 :: 用于实现可靠传输，保证数据完整，分为：超时重传、快速重传
  + 超时重传       :: 发送方设置定时器，超时未受到接收方的确认，重传
  + [[id:5006cd5d-8a75-4a3c-b4a7-572ec37b0637][快速重传]]       :: 接收方每次收到乱序数据包时重复发送期望序号，发送方连续收到3次相同期望序号，重传； *缺陷* ：只能判断连续丢失的首个数据包，无法明确后续的数据包是否丢失，可能导致冗余重传
  + [[id:fdae90c8-d939-454c-aed2-9466a09d3edf][选择性确认]]     :: （SACK）接收方在三次ACK的TCP头的 *选项字段加入SACK* ，表示 已接收的非连续数据的范围，避免冗余重传
  + 重复选择性确认 :: （D-SACK）

📎 [[https://xiaolincoding.com/network/3_tcp/tcp_feature.html#%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6][小林coding]]


*** 🖼 快速重传 :ATTACH:
:PROPERTIES:
:ID:       5006cd5d-8a75-4a3c-b4a7-572ec37b0637
:END:
[[attachment:_20250806_163047screenshot.png]]


*** 🖼 选择性确认 :ATTACH:
:PROPERTIES:
:ID:       fdae90c8-d939-454c-aed2-9466a09d3edf
:END:
[[attachment:_20250821_100918screenshot.png]]


** 一个端口的TCP最大连接数？
:PROPERTIES:
:ID:       4f2fafb7-7a66-4422-b00b-69da24cb1077
:END:
理论  ： =最大TCP连接数 = 客户端IP数 x 客户端端口数=
受限于：每个 TCP连接 都会占用一个 文件描述符
1. 文件描述符数量
2. 内存限制（操作系统）

- TCP四元组 :: 表示 TCP连接， =(源地址，源端口，目标地址，目标端口)=


** TCP和UDP可以使用同一个端口吗？（图文） :ATTACH:
:PROPERTIES:
:ID:       28bcae4c-6ee6-40a4-a77c-d213d4c76223
:END:
可以，TCP 和 UDP 是内核中的两个独立模块，当主机收到数据包后，根据 *IP包头的协议字段* 判断送到哪个模块处理
[[attachment:_20250806_154253screenshot.png]]

📎 [[https://xiaolincoding.com/network/3_tcp/port.html#tcp-%E5%92%8C-udp-%E5%8F%AF%E4%BB%A5%E5%90%8C%E6%97%B6%E7%BB%91%E5%AE%9A%E7%9B%B8%E5%90%8C%E7%9A%84%E7%AB%AF%E5%8F%A3%E5%90%97][小林coding]]
