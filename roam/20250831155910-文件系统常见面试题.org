:PROPERTIES:
:ID:       2087337b-11b7-493b-9492-943e3b38969c
:END:
#+title: 文件系统
#+filetags: fs

* 文件系统
** 文件系统基本组成

📎 [[https://xiaolincoding.com/os/6_file_system/file_system.html#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90][小林coding]]

*** 索引节点和目录项
文件 关联的2个数据结构：[[id:6e6aae7c-ce87-40dc-ac53-1c0ff61e6f4e][🖼 索引节点、目录项、文件数据]]
*dentry和inode关系*
1. 创建文件时：内核在磁盘上分配一个磁盘inode，并给它分配唯一inode号；内核在内存中创建dentry，存储文件名和inode号的映射关系
2. 读取文件时：内核通过dentry找到其对应的inode号，将磁盘inode加载到内存，生成内存inode
#+name: 为什么要有dentry？
#+begin_comment
用户不会通过inode号访问文件，而是使用文件名，dentry就存储了 “文件名-inode号” 映射
#+end_comment

名词解释：文件名、dentry、inode、fd
- 文件名          :: 方便用户识别和查找文件

- dentry(目录项)  ::
  1. 记录“文件名-inode号”的映射关系，存储在 *内存* 中
  2. 记录：文件名、inode指针、与其他目录项的层级关联关系
  3. =ls -l= 查看dentry
#+name: 目录和目录项的区别？
  #+begin_comment
  目录  ：是文件
  目录项：是内存中的数据结构，记录文件和inode号的映射关系，因此除了记录普通文件，也记录目录
  #+end_comment

- inode(索引节点) ::
  1. 是 *文件的唯一标识* ，存储在 *磁盘、内存* 中
  2. 记录文件的元信息： *数据在磁盘的位置* 、inode编号、文件大小、访问权限、创建时间、修改时间
  3. stat 查看 inode

- fd(文件描述符)  :: 进程打开文件后，内核为进程分配的临时整数索引
#+name: inode和fd的区别？
#+begin_comment
- inode用于定位文件或者说唯一标识文件
- fd用于说明进程可以怎么操作文件（eg：不同进程对同一个文件的访问权限不同：可读可写，文件读到哪了等）
#+end_comment


*** 磁盘的3个存储区域
- 超级块     :: 存储 文件系统详细信息：块个数、块大小、空闲块等； *文件系统挂载时进入内存*
- 索引节点区 :: 存储 索引节点； *文件访问时进入内存*
- 数据块区   :: 存储 文件或目录数据
  + 数据块（4KB） :: 也称 *逻辑块* ，由8个扇区组成；是文件系统读写的基本单位
  + 扇区（512B）  :: 磁盘读写最小单位


*** 🖼 索引节点、目录项、文件数据 :ATTACH:
:PROPERTIES:
:ID:       6e6aae7c-ce87-40dc-ac53-1c0ff61e6f4e
:END:
[[attachment:_20250831_205007screenshot.png]]


** 虚拟文件系统(VFS)
用于为用户 *提供统一的文件系统访问接口* ，见：[[id:55c4bfc0-b968-4e74-bead-420599fcbe8d][🖼 虚拟文件系统]]
#+begin_comment
文件系统多样，原理和使用方式也多样；引入VFS，程序员只需要了解VFS提供的统一接口就行
#+end_comment

*linux支持的文件系统*
# 文件系统只有挂载在某个目录后才可使用
1. 磁盘的文件系统：数据存在 磁盘 中，eg：ext2/3/4、XFS
2. 内存的文件系统：数据存在 内存 中，eg：/proc、/sys，读写这类文件其实是读写内核中相关数据
3. 网络的文件系统：用于访问其他计算机主机数据的文件系统，eg：NFS、SMB


*** 🖼 虚拟文件系统 :ATTACH:
:PROPERTIES:
:ID:       55c4bfc0-b968-4e74-bead-420599fcbe8d
:END:
[[attachment:_20251105_162948screenshot.png]]


** 软链接、硬链接
*[[id:df162b8c-110a-4d17-ac3f-f0274e0cd113][硬链接]]*
1. 多个dentry中的inode指针指向同一个inode
   只有删除文件的所有硬链接和源文件时，系统才会删除该文件
2. 不可跨文件系统
3. 不可链接目录

*[[id:76c74ce5-c50b-4f27-989f-52edcfda9207][软链接]]*
1. 创建一个新文件，存储另一个文件的路径
   删除源文件，软链接文件还存在，只是找不到源文件
2. 可跨文件系统
3. 可链接目录


*** 🖼 硬链接 :ATTACH:
:PROPERTIES:
:ID:       df162b8c-110a-4d17-ac3f-f0274e0cd113
:END:
[[attachment:_20251105_164335screenshot.png]]


*** 🖼 软链接 :ATTACH:
:PROPERTIES:
:ID:       76c74ce5-c50b-4f27-989f-52edcfda9207
:END:
[[attachment:_20251105_164342screenshot.png]]


* tmp
** 文件的使用
进程打开文件后，操作系统通过文件名找到对应 inode，然后操作系统在 *打开文件表* 创建一个条目，包含：
- inode指针     ：指向inode，以此找到文件
- 文件指针      ：记录上次文件的读写位置
- 文件打开计数器：多个进程可能打开同一个文件，当这些进程都关闭文件后，计数归0，操作系统关闭文件，删除 该条目
- 访问权限      ：创建、只读、读写、添加等
并为这个条目分配一个 fd 返回给进程


** 文件的存储
被占用数据块的组织和管理
*** 连续空间存放方式(图) :ATTACH:
:PROPERTIES:
:ID:       4361fef0-0511-480d-b535-ab6ca7b73de0
:END:
[[attachment:_20250831_221646screenshot.png]]
# 这里的 文件头 类似 linux 的 inode
*顺序方式* ：
文件 存放在连续的磁盘空间，有一个 文件头（包含：起始块、长度）用来表示文件存放位置，读写效率高，但是 有磁盘空间碎片、文件长度不易扩展 的缺陷

*** 非连续空间存放方式(图)
非连续空间存放方式 分为：链表方式、索引方式

*链表方式* ：
文件的存放可以是不连续的；可以消除磁盘碎片，且文件长度可以扩展
- 隐式链表 :: 文件头 包含 起始块和末尾块的位置，每个块内都有指针，指向下一个块；只能顺序访问，读写效率低，且指针可能丢失或损坏，导致文件数据丢失
- 显示链表 :: *文件分配表(FAT)* 表中的项记录下一个块的位置，到 -1 为止；存储在磁盘中，后续被加载到内存，检索速度快、减少访问磁盘的次数，但不适用于大磁盘

*索引方式* ：
磁盘中为每个文件创建一个 索引块（存放指向文件数据块的指针列表），文件头里存在指向 索引块的指针；文件创建、增大、缩小很方便，没有碎片问题，支持顺序、随机读写，读写效率高
- 链式索引块 :: 索引块 以 链表的形式链接起来；解决了大文件一个索引块不够的问题
- 多级索引块 :: 在链式索引块的基础上，增加 上级索引块，里面存放各个索引块的位置

*** unix文件的实现方式
实现方式：顺序 + 链表 + 索引；文件头（inode）包含 13个指针：
- 10个  指向 数据块    ：数据块 < 10，直接查找（小文件 直接查找，减少索引数据块开销）
- 第11个指向 索引块    ：数据块 > 10，一级索引查找
- 第12个指向 二级索引块：一级索引不够，二级索引查找
- 第13个指向 三级索引块：二级索引不够，三级索引查找
ext2/3使用，支持 小文件、大文件 存放问题，但是大文件访问效率较低，ext4针对此问题做了一定改变

**** 图:unix文件的实现方式 :ATTACH:
:PROPERTIES:
:ID:       5224fcb5-c8fb-4710-ac8e-b1dddf300b81
:END:
[[attachment:_20250901_144007screenshot.png]]


** 目录的存储
目录inode指向的 目录数据块：包含 当前目录、上级目录 以及 当前目录中包含的文件
当前目录中包含的文件 是以 哈希表的形式存储的：key 为 文件名计算后的哈希值，value 为对应 块号


** 空闲空间管理
保存一个数据块，应该放什么位置；3种方法：空闲表法、空闲链表法、位图法

*空闲表法* ：
1. 文件存储是 顺序方式
2. 有一张空闲表里面的每一项记录了 第一个空闲块号、空闲块个数

*空闲链表法* ：
1. 用链表形式将空闲块组织起来

*位图法* ：
1. linux采用
2. 用二进制的一位表示磁盘中一个盘块的使用情况，0表示盘块空闲，1表示已分配


** linux文件系统结构
用 *块组* 的形式存储文件；见：[[id:2ca83788-36d1-407f-b923-eb652587df4c][图:块组]]
#+begin_comment
按上述所说的 *超级块+数据位图+inode位图+inode列表+数据块* 的形式能表示的最大文件也就 128M，太小了，因此 linux 使用 块组，可以表示任意大的文件
#+end_comment

*** 图:块组 :ATTACH:
:PROPERTIES:
:ID:       2ca83788-36d1-407f-b923-eb652587df4c
:END:
[[attachment:_20250901_135715screenshot.png]]
- 超级块              :: 包含文件系统重要信息：inode总数、块总数（全局信息，冗余，用于文件系统恢复）；每个块组的inode个数、块个数等
- 块组描述符          :: 文件系统中各个块组状态（全局信息，冗余，用于文件系统恢复）：块组中空闲块、及对应inode数量
- 数据位图、inode位图 :: 表示哪些数据块、inode是空闲的
- inode列表           :: 包含 inode
- 数据块              :: 包含 真实数据
