:PROPERTIES:
:ID:       38a82890-b4b8-4985-978d-7e9dff72a291
:END:
#+title: 零拷贝
#+filetags: os

* 零拷贝
通过减少 =CPU上下文切换次数= （用户态/内核态）、 =数据拷贝次数= 来提高 *文件传输* 性能（相较于 [[id:a8a0a3ed-b99d-4638-9530-0fdb0c815676][传统文件传输]]）

具体2种方法：
# 传统拷贝：read + write，4次拷贝 + 4次上下文切换
1. mmap + write： =3次拷贝 + 4次上下文切换=
2. sendfile    ： =3次拷贝 + 2次上下文切换= ；在支持 SG-DMA的网卡 中使用sendfile， =2次拷贝 + 2次上下文切换= （全程没有CPU参与，这是真正的零拷贝技术）

*注* ：这里的内核缓冲区是指 [[id:5007d3f1-963b-48d3-88ff-261c4b4e454e][PageCache]]

📎 [[https://xiaolincoding.com/os/8_network_system/zero_copy.html#_9-1-%E4%BB%80%E4%B9%88%E6%98%AF%E9%9B%B6%E6%8B%B7%E8%B4%9D][小林coding]]


** 方法1: mmap + write（图文） :ATTACH:
:PROPERTIES:
:ID:       5e2d966e-25e2-449a-bae7-94af7f42231b
:END:
#+begin_example C
buf = mmap(file, len);
write(sockfd, buf, len);
#+end_example
[[attachment:_20250826_153906screenshot.png]]
1. 进程调用 mmap() 将 内核缓冲区 映射到 进程的用户缓冲区（后续在用户缓冲区的操作同步到内核缓冲区，相比传统文件传输的好处： *数据拷贝不需要经过用户缓冲区* ）
2. 通过 DMA 将磁盘数据 *拷贝* 到内核缓冲区（PageCache）
3. 进程调用 write() ，CPU 将数据 *拷贝* 到 内核的socket缓冲区
4. 通过 DMA 将内核缓冲区数据 *拷贝* 到 网卡
3次拷贝 + 4次上下文切换（用户态内核态切换）


** 方法2: sendfile（图文） :ATTACH:
:PROPERTIES:
:ID:       f45b2383-983a-4389-85bc-00cbf975eeca
:END:
#+begin_example C
ssize_t sendfile(int out_fd, int in_fd, off_t* offset, size_t count);
// out_fd：输出文件描述符（通常是网络套接字 socket）
// in_fd ：输入文件描述符（必须是支持 mmap 操作的文件，不能是套接字）
// offset：指定从输入文件的哪个位置开始读取数据。若为 NULL，则从当前文件指针位置开始，并自动更新文件指针
// count ：要传输的字节数
#+end_example
[[attachment:_20250826_155042screenshot.png]]
sendfile 用于在内核态中拷贝数据
3次拷贝 + 2次上下文切换（用户态内核态切换）


*** 🖼 sendfile（网卡支持SG-DMA） :ATTACH:
:PROPERTIES:
:ID:       94e2ca69-cd07-40a2-9a43-4c0526fbbbdd
:END:
[[attachment:_20250826_155215screenshot.png]]
1. DMA 将磁盘数据拷贝到 内核缓冲区
2. 缓冲区fd和数据长度 传到 socket缓冲区
3. 网卡的 SG-DMA控制器 将内核缓冲区数据 拷贝到 网卡缓冲区
全程没有CPU参与
2次拷贝 + 2次上下文切换（用户态内核态切换）


* 传统文件传输（图文） :ATTACH:
:PROPERTIES:
:ID:       a8a0a3ed-b99d-4638-9530-0fdb0c815676
:END:
#+begin_example C
read(file, tmp_buf, len);
write(socket, tmp_buf, len);
#+end_example
[[attachment:_20250826_152130screenshot.png]]
4次拷贝 + 4次上下文切换（用户态内核态切换）


* DMA技术（直接内存访问）
:PROPERTIES:
:ID:       db3db3e0-12f9-4963-8964-884ecda75b40
:END:
*作用* ：无需CPU参与I/O设备、内核缓冲区之间的数据传输；而是交给DMA控制器来做
- CPU拷贝 :: CPU将数据从源内存区域读取到CPU寄存器，再将数据写入到目标内存区域
#+begin_comment
现代设备       ：I/O设备（eg：网卡、显卡、硬盘） 一般内置自己的专用DMA控制器
传统/嵌入式设备：系统中有一个中央的公用的DMA控制器
#+end_comment


** 有无DMA控制器的I/O过程
# 以将磁盘数据读取到用户缓冲区为例
*无DMA控制器* ：
1. 进程调用 read()，阻塞： *用户态 -> 内核态*
2. CPU 发出IO请求给 磁盘控制器
3. 磁盘控制器 将数据 *拷贝* 磁盘控制器内部的缓冲区中，发出中断通知 CPU
4. CPU 从磁盘控制器的缓冲区中的数据 *拷贝* 到 PageCache（这个期间 CPU 无法执行其他任务）
5. CPU 将数据从 PageCache *拷贝* 到 用户缓冲区         （这个期间 CPU 无法执行其他任务）
6. 从 read() 返回： *内核态 -> 用户态*

*有DMA控制器* ：
1. 进程调用 read()，阻塞： *用户态 -> 内核态*
2. CPU 发出IO请求给 DMA控制器，返回；DMA控制器 发出IO请求给 磁盘控制器
3. 磁盘控制器 将数据 *拷贝* 磁盘控制器内部的缓冲区中，通知 DMA控制器
4. DMA控制器 从磁盘控制器的缓冲区中 *拷贝* 到 PageCache，通知 CPU
5. CPU 将数据从 PageCache *拷贝* 到 用户缓冲区
6. 从 read() 返回： *内核态 -> 用户态*


* 小/大文件传输方式选择？
小文件：零拷贝技术
大文件：异步IO + 直接IO
#+begin_comment
零拷贝技术要走 PageCache，PageCache 是用于存放常访问的页面，传输小文件还好，传输大文件就会占满 PageCache，大文件要么直接给用户使用，要么从网卡发出去，这导致 PageCache 功能无效化。
假设传输大文件使用 零拷贝，则大文件会占满 PageCache，导致无法用到缓存，增大性能开销
异步IO 不涉及 PageCache
#+end_comment
