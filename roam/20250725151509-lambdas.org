:PROPERTIES:
:ID:       926134dd-d8b9-4358-a89d-e84ce92a735f
:END:
#+title: lambda表达式
#+filetags: cpp

* lambda表达式
- lambda表达式 :: 本质上是 *匿名仿函数*
  + 仿函数 :: 重载了 =operator()= 的类对象，使得它们可以像函数一样被调用，仿函数是 *带状态的* （不同于函数，类中的成员变量可以保存状态）
#+begin_src cpp
[ captureClause ] ( parameters ) -> returnType
{
    statements;
}
// [] 捕获外部块的标识符
// returnType 可省略。若没指定 returnType，则 () 也能省略
[]{}; // 省略的终极形态
#+end_src

** 性质
1. 闭包 *类型* （每个 lambda表达式 的类型都是独一无二的，因为本质是匿名类对象，而类名就是类型名），用 =auto= 推导类型，总结 *存储* lambda表达式 的方式：
   1) [[id:bee683d2-eec4-45a8-af02-be369d182e8d][auto]]（推荐）
   2) std::function
   3) [[id:ee21abb8-cd89-4207-bbbe-49c4ed887fed][函数指针]]

2. *返回类型推导* ：若 lambda表达式内部多个 return 的类型不同，指定 后置返回类型[fn:1]

3. *lambda捕获* ：值捕获、引用捕获
   1) *值捕获 原理* ：值捕获的变量，在lambda内部创建一个外部变量的拷贝（名称相同且用外部变量初始化）作为 成员变量
   2) 值捕获 的变量是 *常量* ，使用 =mutable= 才能修改（修改的是内部的副本）[fn:2]
      引用捕获 的变量 *不是常量* ，可以修改捕获的变量 [fn:3]
   3) *默认捕获* ： === 值捕获所有变量， =&= 引用捕获所有变量 [fn:4]
   4) *捕获的同时定义新变量*
      #+begin_src cpp
      // 捕获外部的 width、height 定义新变量 userArea
      [userArea{ width * height }](int knownArea) {
        return userArea == knownArea
      }
      #+end_src

* Footnotes

[fn:1]
#+begin_src cpp :results output :namespaces std :includes <iostream>
int main()
{
  // FIXME 发生错误的情况：两个 return 返回类型不同
  // auto divide{ [](int x, int y, bool intDivision) {
  //   if ...
  //     return x / y;                      // int
  //   else
  //     return static_cast<double>(x) / y; // double
  // }

  // NOTE 显式指定 后置返回类型
  auto divide{ [](int x, int y, bool intDivision) -> double {
    if (intDivision)
      return x / y;                         // 编译器根据 后置返回类型 进行隐式转换
    else
      return static_cast<double>(x) / y;
  } };

  std::cout << divide(3, 2, true) << '\n';
  std::cout << divide(3, 2, false) << '\n';
}
#+end_src

[fn:2]
#+name: 值捕获的变量是常量，不可修改
#+begin_src cpp :results output :namespaces std :includes <iostream>
int main()
{
  int ammo{ 10 };

  // Define a lambda and store it in a variable called "shoot".
  auto shoot{
    [ammo]() {
      // FIXME ammo 不能修改，因为 值捕获的是常量
      --ammo;

      std::cout << "Pew! " << ammo << " shot(s) left.\n";
    }
  };

  // Call the lambda
  shoot();

  std::cout << ammo << " shot(s) left\n";

  return 0;
}
#+end_src

#+name: 通过 mutable 修改值捕获的变量（常量）
#+begin_src cpp :results output :namespaces std :includes <iostream>
int main()
{
  int ammo{ 10 };

  auto shoot{
    [ammo]() mutable { // 现在是 mutable
      // 现在可以修改 ammo
      --ammo;

      std::cout << "Pew! " << ammo << " shot(s) left.\n";
    }
  };

  shoot();
  shoot();

  std::cout << ammo << " shot(s) left\n";

  return 0;
}
#+end_src

[fn:3]
#+begin_src cpp :results output :namespaces std :includes <iostream>
int main()
{
  int ammo{ 10 };

  auto shoot{
    // 引用捕获
    [&ammo]() {
      // 修改 ammo
      --ammo;

      std::cout << "Pew! " << ammo << " shot(s) left.\n";
    }
  };

  shoot();

  std::cout << ammo << " shot(s) left\n";

  return 0;
}
#+end_src

#+RESULTS:
: Pew! 9 shot(s) left.
: 9 shot(s) left

[fn:4]
#+begin_src cpp
int health{ 33 };
int armor{ 100 };
std::vector<CEnemy> enemies{};

// 值捕获 health、armor, 引用捕获 enemies
[health, armor, &enemies](){};
// 引用捕获 enemies，值捕获 其他所有
[=, &enemies](){};
// 值捕获 armor，引用捕获 其他所有
[&, armor](){};
#+end_src
